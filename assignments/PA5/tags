!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/root/Downloads/cs143/assignments/PA5/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
${CSRC}	Makefile	/^${TSRC} ${CSRC}:$/;"	t
${HSRC}	Makefile	/^${HSRC}:$/;"	t
${LIBS}	Makefile	/^${LIBS}:$/;"	t
${OUTPUT}	Makefile	/^${OUTPUT}:	cgen$/;"	t
${TSRC}	Makefile	/^${TSRC} ${CSRC}:$/;"	t
%.d	Makefile	/^%.d: %.cc ${SRC}$/;"	t
.cc.o	Makefile	/^.cc.o:$/;"	t
A1	emit.h	/^#define A1 /;"	d
ACC	emit.h	/^#define ACC /;"	d
ADD	emit.h	/^#define ADD /;"	d
ADDI	emit.h	/^#define ADDI /;"	d
ADDIU	emit.h	/^#define ADDIU /;"	d
ADDU	emit.h	/^#define ADDU /;"	d
ALIGN	emit.h	/^#define ALIGN /;"	d
AR	Makefile	/^AR= gar$/;"	m
ARCHIVE_NEW	Makefile	/^ARCHIVE_NEW= -cr$/;"	m
ASSIGN	ast-parse.cc	/^     ASSIGN = 264,$/;"	e	enum:yytokentype	file:	access:public
ASSIGN	ast-parse.cc	/^#define ASSIGN /;"	d	file:
ASSIGN	ast-parse.h	/^     ASSIGN = 264,$/;"	e	enum:yytokentype	access:public
ASSIGN	ast-parse.h	/^#define ASSIGN /;"	d
ASSIGN	cool-parse.h	/^     ASSIGN = 280,$/;"	e	enum:yytokentype	access:public
ASSIGN	cool-parse.h	/^#define ASSIGN /;"	d
ASSN	Makefile	/^ASSN = 5$/;"	m
ATTR	ast-parse.cc	/^     ATTR = 261,$/;"	e	enum:yytokentype	file:	access:public
ATTR	ast-parse.cc	/^#define ATTR /;"	d	file:
ATTR	ast-parse.h	/^     ATTR = 261,$/;"	e	enum:yytokentype	access:public
ATTR	ast-parse.h	/^#define ATTR /;"	d
BEGIN	ast-lex.cc	/^#define BEGIN /;"	d	file:
BEQ	emit.h	/^#define BEQ /;"	d
BEQZ	emit.h	/^#define BEQZ /;"	d
BFLAGS	Makefile	/^BFLAGS = -d -v -y -b cool --debug -p cool_yy$/;"	m
BGT	emit.h	/^#define BGT /;"	d
BISON	Makefile	/^BISON= bison ${BFLAGS}$/;"	m
BLEQ	emit.h	/^#define BLEQ /;"	d
BLOCK	ast-parse.cc	/^     BLOCK = 270,$/;"	e	enum:yytokentype	file:	access:public
BLOCK	ast-parse.cc	/^#define BLOCK /;"	d	file:
BLOCK	ast-parse.h	/^     BLOCK = 270,$/;"	e	enum:yytokentype	access:public
BLOCK	ast-parse.h	/^#define BLOCK /;"	d
BLT	emit.h	/^#define BLT /;"	d
BNE	emit.h	/^#define BNE /;"	d
BOOL	ast-parse.cc	/^     BOOL = 283,$/;"	e	enum:yytokentype	file:	access:public
BOOL	ast-parse.cc	/^#define BOOL /;"	d	file:
BOOL	ast-parse.h	/^     BOOL = 283,$/;"	e	enum:yytokentype	access:public
BOOL	ast-parse.h	/^#define BOOL /;"	d
BOOLCONST_PREFIX	emit.h	/^#define BOOLCONST_PREFIX /;"	d
BOOLNAME	emit.h	/^#define BOOLNAME /;"	d
BOOLTAG	emit.h	/^#define BOOLTAG /;"	d
BOOL_CONST	cool-parse.h	/^     BOOL_CONST = 277,$/;"	e	enum:yytokentype	access:public
BOOL_CONST	cool-parse.h	/^#define BOOL_CONST /;"	d
BOOL_SLOTS	emit.h	/^#define BOOL_SLOTS /;"	d
BRANCH	ast-parse.cc	/^     BRANCH = 263,$/;"	e	enum:yytokentype	file:	access:public
BRANCH	ast-parse.cc	/^#define BRANCH /;"	d	file:
BRANCH	ast-parse.h	/^     BRANCH = 263,$/;"	e	enum:yytokentype	access:public
BRANCH	ast-parse.h	/^#define BRANCH /;"	d
BRANCH	emit.h	/^#define BRANCH /;"	d
Basic	cgen.h	/^enum Basicness     {Basic, NotBasic};$/;"	e	enum:Basicness	access:public
Basicness	cgen.h	/^enum Basicness     {Basic, NotBasic};$/;"	g
Bool	cgen.cc	/^	Bool,$/;"	v	typeref:typename:Symbol
BoolConst	cgen.cc	/^BoolConst::BoolConst(int i) : val(i) { assert(i == 0 || i == 1); }$/;"	f	class:BoolConst	signature:(int i)
BoolConst	cgen.h	/^		BoolConst(int);$/;"	p	class:BoolConst	access:public	signature:(int)
BoolConst	cgen.h	/^class BoolConst {$/;"	c
BoolConst::BoolConst	cgen.cc	/^BoolConst::BoolConst(int i) : val(i) { assert(i == 0 || i == 1); }$/;"	f	class:BoolConst	signature:(int i)
BoolConst::BoolConst	cgen.h	/^		BoolConst(int);$/;"	p	class:BoolConst	access:public	signature:(int)
BoolConst::code_def	cgen.cc	/^void BoolConst::code_def(ostream& s, int boolclasstag)$/;"	f	class:BoolConst	typeref:typename:void	signature:(ostream & s,int boolclasstag)
BoolConst::code_def	cgen.h	/^		void code_def(ostream&, int boolclasstag);$/;"	p	class:BoolConst	typeref:typename:void	access:public	signature:(ostream &,int boolclasstag)
BoolConst::code_ref	cgen.cc	/^void BoolConst::code_ref(ostream& s) const$/;"	f	class:BoolConst	typeref:typename:void	signature:(ostream & s) const
BoolConst::code_ref	cgen.h	/^		void code_ref(ostream&) const;$/;"	p	class:BoolConst	typeref:typename:void	access:public	signature:(ostream &) const
BoolConst::val	cgen.h	/^		int val;$/;"	m	class:BoolConst	typeref:typename:int	access:private
Boolean	ast-parse.h	/^typedef int Boolean;$/;"	t	typeref:typename:int
Boolean	cool-parse.h	/^typedef int Boolean;$/;"	t	typeref:typename:int
Boolean	cool.h	/^typedef int Boolean;$/;"	t	typeref:typename:int
CASE	cool-parse.h	/^     CASE = 269,$/;"	e	enum:yytokentype	access:public
CASE	cool-parse.h	/^#define CASE /;"	d
CC	Makefile	/^CC=g++$/;"	m
CFIL	Makefile	/^CFIL= cgen.cc cgen_supp.cc ${CSRC} ${CGEN}$/;"	m
CGEN	Makefile	/^CGEN=$/;"	m
CLASS	Makefile	/^CLASS= cs143$/;"	m
CLASS	ast-parse.cc	/^     CLASS = 259,$/;"	e	enum:yytokentype	file:	access:public
CLASS	ast-parse.cc	/^#define CLASS /;"	d	file:
CLASS	ast-parse.h	/^     CLASS = 259,$/;"	e	enum:yytokentype	access:public
CLASS	ast-parse.h	/^#define CLASS /;"	d
CLASS	cool-parse.h	/^     CLASS = 258,$/;"	e	enum:yytokentype	access:public
CLASS	cool-parse.h	/^#define CLASS /;"	d
CLASSDIR	Makefile	/^CLASSDIR= ..\/..$/;"	m
CLASSINIT_SUFFIX	emit.h	/^#define CLASSINIT_SUFFIX /;"	d
CLASSNAMETAB	emit.h	/^#define CLASSNAMETAB /;"	d
CLASSOBJTAB	emit.h	/^#define CLASSOBJTAB /;"	d
COMP	ast-parse.cc	/^     COMP = 280,$/;"	e	enum:yytokentype	file:	access:public
COMP	ast-parse.cc	/^#define COMP /;"	d	file:
COMP	ast-parse.h	/^     COMP = 280,$/;"	e	enum:yytokentype	access:public
COMP	ast-parse.h	/^#define COMP /;"	d
COND	ast-parse.cc	/^     COND = 267,$/;"	e	enum:yytokentype	file:	access:public
COND	ast-parse.cc	/^#define COND /;"	d	file:
COND	ast-parse.h	/^     COND = 267,$/;"	e	enum:yytokentype	access:public
COND	ast-parse.h	/^#define COND /;"	d
COOL_IO_H	cool-io.h	/^#define COOL_IO_H$/;"	d
COOL_TREE_H	cool-tree.h	/^#define COOL_TREE_H$/;"	d
COOL_TREE_HANDCODE_H	cool-tree.handcode.h	/^#define COOL_TREE_HANDCODE_H$/;"	d
CPPINCLUDE	Makefile	/^CPPINCLUDE= -I. -I${CLASSDIR}\/include\/PA${ASSN} -I${CLASSDIR}\/src\/PA${ASSN}$/;"	m
CSRC	Makefile	/^CSRC= cgen-phase.cc utilities.cc stringtab.cc dumptype.cc tree.cc cool-tree.cc ast-lex.cc ast-pa/;"	m
Case	ast-parse.h	/^typedef class Case_class *Case;$/;"	t	typeref:class:Case_class *
Case	cool-parse.h	/^typedef class Case_class *Case;$/;"	t	typeref:class:Case_class *
Case	cool-tree.h	/^typedef class Case_class *Case;$/;"	t	typeref:class:Case_class *
Case	cool-tree.handcode.h	/^typedef Case_class *Case;$/;"	t	typeref:typename:Case_class *
Case_EXTRAS	cool-tree.handcode.h	/^#define Case_EXTRAS /;"	d
Case_class	cool-tree.h	/^class Case_class : public tree_node {$/;"	c	inherits:tree_node
Case_class::copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Case(); }$/;"	f	class:Case_class	typeref:typename:tree_node *	access:public	signature:()
Case_class::copy_Case	cool-tree.h	/^   virtual Case copy_Case() = 0;$/;"	p	class:Case_class	typeref:typename:Case	access:public	signature:()
Cases	ast-parse.h	/^typedef Cases_class *Cases;$/;"	t	typeref:typename:Cases_class *
Cases	cool-parse.h	/^typedef Cases_class *Cases;$/;"	t	typeref:typename:Cases_class *
Cases	cool-tree.h	/^typedef Cases_class *Cases;$/;"	t	typeref:typename:Cases_class *
Cases	cool-tree.handcode.h	/^typedef Cases_class *Cases;$/;"	t	typeref:typename:Cases_class *
Cases_class	ast-parse.h	/^typedef list_node<Case> Cases_class;$/;"	t	typeref:typename:list_node<Case>
Cases_class	cool-parse.h	/^typedef list_node<Case> Cases_class;$/;"	t	typeref:typename:list_node<Case>
Cases_class	cool-tree.h	/^typedef list_node<Case> Cases_class;$/;"	t	typeref:typename:list_node<Case>
Cases_class	cool-tree.handcode.h	/^typedef list_node<Case> Cases_class;$/;"	t	typeref:typename:list_node<Case>
CgenClassTable	cgen.cc	/^CgenClassTable::CgenClassTable(Classes classes, ostream& s) : nds(NULL) , str(s)$/;"	f	class:CgenClassTable	signature:(Classes classes,ostream & s)
CgenClassTable	cgen.h	/^		CgenClassTable(Classes, ostream& str);$/;"	p	class:CgenClassTable	access:public	signature:(Classes,ostream & str)
CgenClassTable	cgen.h	/^class CgenClassTable : public SymbolTable<Symbol,CgenNode> {$/;"	c	inherits:SymbolTable<Symbol,CgenNode>
CgenClassTable::CgenClassTable	cgen.cc	/^CgenClassTable::CgenClassTable(Classes classes, ostream& s) : nds(NULL) , str(s)$/;"	f	class:CgenClassTable	signature:(Classes classes,ostream & s)
CgenClassTable::CgenClassTable	cgen.h	/^		CgenClassTable(Classes, ostream& str);$/;"	p	class:CgenClassTable	access:public	signature:(Classes,ostream & str)
CgenClassTable::boolclasstag	cgen.h	/^		int boolclasstag;$/;"	m	class:CgenClassTable	typeref:typename:int	access:private
CgenClassTable::build_inheritance_tree	cgen.cc	/^void CgenClassTable::build_inheritance_tree()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
CgenClassTable::build_inheritance_tree	cgen.h	/^		void build_inheritance_tree();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
CgenClassTable::code	cgen.cc	/^void CgenClassTable::code()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
CgenClassTable::code	cgen.h	/^		void code();$/;"	p	class:CgenClassTable	typeref:typename:void	access:public	signature:()
CgenClassTable::code_bools	cgen.cc	/^void CgenClassTable::code_bools(int boolclasstag)$/;"	f	class:CgenClassTable	typeref:typename:void	signature:(int boolclasstag)
CgenClassTable::code_bools	cgen.h	/^		void code_bools(int);$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:(int)
CgenClassTable::code_class_dispTab	cgen.cc	/^void CgenClassTable::code_class_dispTab()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
CgenClassTable::code_class_dispTab	cgen.h	/^		void code_class_dispTab();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
CgenClassTable::code_class_init	cgen.cc	/^void CgenClassTable::code_class_init() { root()->code_init(str); }$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
CgenClassTable::code_class_init	cgen.h	/^		void code_class_init();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
CgenClassTable::code_class_nameTab	cgen.cc	/^void CgenClassTable::code_class_nameTab()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
CgenClassTable::code_class_nameTab	cgen.h	/^		void code_class_nameTab();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
CgenClassTable::code_class_objTab	cgen.cc	/^void CgenClassTable::code_class_objTab()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
CgenClassTable::code_class_objTab	cgen.h	/^		void code_class_objTab();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
CgenClassTable::code_class_protObj	cgen.cc	/^void CgenClassTable::code_class_protObj() {$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
CgenClassTable::code_class_protObj	cgen.h	/^		void code_class_protObj();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
CgenClassTable::code_constants	cgen.cc	/^void CgenClassTable::code_constants()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
CgenClassTable::code_constants	cgen.h	/^		void code_constants();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
CgenClassTable::code_global_data	cgen.cc	/^void CgenClassTable::code_global_data()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
CgenClassTable::code_global_data	cgen.h	/^		void code_global_data();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
CgenClassTable::code_global_text	cgen.cc	/^void CgenClassTable::code_global_text()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
CgenClassTable::code_global_text	cgen.h	/^		void code_global_text();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
CgenClassTable::code_methods_init	cgen.cc	/^void CgenClassTable::code_methods_init() {$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
CgenClassTable::code_methods_init	cgen.h	/^		void code_methods_init();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
CgenClassTable::code_select_gc	cgen.cc	/^void CgenClassTable::code_select_gc()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
CgenClassTable::code_select_gc	cgen.h	/^		void code_select_gc();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
CgenClassTable::execute	cgen.h	/^		void execute();$/;"	p	class:CgenClassTable	typeref:typename:void	access:public	signature:()
CgenClassTable::install_basic_classes	cgen.cc	/^void CgenClassTable::install_basic_classes()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
CgenClassTable::install_basic_classes	cgen.h	/^		void install_basic_classes();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
CgenClassTable::install_class	cgen.cc	/^void CgenClassTable::install_class(CgenNodeP nd)$/;"	f	class:CgenClassTable	typeref:typename:void	signature:(CgenNodeP nd)
CgenClassTable::install_class	cgen.h	/^		void install_class(CgenNodeP nd);$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:(CgenNodeP nd)
CgenClassTable::install_classes	cgen.cc	/^void CgenClassTable::install_classes(Classes cs)$/;"	f	class:CgenClassTable	typeref:typename:void	signature:(Classes cs)
CgenClassTable::install_classes	cgen.h	/^		void install_classes(Classes cs);$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:(Classes cs)
CgenClassTable::intclasstag	cgen.h	/^		int intclasstag;$/;"	m	class:CgenClassTable	typeref:typename:int	access:private
CgenClassTable::nds	cgen.h	/^		List<CgenNode> *nds;$/;"	m	class:CgenClassTable	typeref:typename:List<CgenNode> *	access:private
CgenClassTable::root	cgen.cc	/^CgenNodeP CgenClassTable::root()$/;"	f	class:CgenClassTable	typeref:typename:CgenNodeP	signature:()
CgenClassTable::root	cgen.h	/^		CgenNodeP root();$/;"	p	class:CgenClassTable	typeref:typename:CgenNodeP	access:public	signature:()
CgenClassTable::set_relations	cgen.cc	/^void CgenClassTable::set_relations(CgenNodeP nd)$/;"	f	class:CgenClassTable	typeref:typename:void	signature:(CgenNodeP nd)
CgenClassTable::set_relations	cgen.h	/^		void set_relations(CgenNodeP nd);$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:(CgenNodeP nd)
CgenClassTable::str	cgen.h	/^		ostream& str;$/;"	m	class:CgenClassTable	typeref:typename:ostream &	access:private
CgenClassTable::stringclasstag	cgen.h	/^		int stringclasstag;$/;"	m	class:CgenClassTable	typeref:typename:int	access:private
CgenClassTableP	cgen.h	/^typedef CgenClassTable *CgenClassTableP;$/;"	t	typeref:typename:CgenClassTable *
CgenNode	cgen.cc	/^CgenNode::CgenNode(Class_ nd, Basicness bstatus, CgenClassTableP ct) :$/;"	f	class:CgenNode	signature:(Class_ nd,Basicness bstatus,CgenClassTableP ct)
CgenNode	cgen.h	/^		CgenNode(Class_ c,$/;"	p	class:CgenNode	access:public	signature:(Class_ c,Basicness bstatus,CgenClassTableP class_table)
CgenNode	cgen.h	/^class CgenNode : public class__class {$/;"	c	inherits:class__class
CgenNode::CgenNode	cgen.cc	/^CgenNode::CgenNode(Class_ nd, Basicness bstatus, CgenClassTableP ct) :$/;"	f	class:CgenNode	signature:(Class_ nd,Basicness bstatus,CgenClassTableP ct)
CgenNode::CgenNode	cgen.h	/^		CgenNode(Class_ c,$/;"	p	class:CgenNode	access:public	signature:(Class_ c,Basicness bstatus,CgenClassTableP class_table)
CgenNode::add_child	cgen.cc	/^void CgenNode::add_child(CgenNodeP n)$/;"	f	class:CgenNode	typeref:typename:void	signature:(CgenNodeP n)
CgenNode::add_child	cgen.h	/^		void add_child(CgenNodeP child);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(CgenNodeP child)
CgenNode::attr_index	cgen.h	/^		std::map<Symbol, int> attr_index;$/;"	m	class:CgenNode	typeref:typename:std::map<Symbol,int>	access:public
CgenNode::basic	cgen.h	/^		int basic() { return (basic_status == Basic); }$/;"	f	class:CgenNode	typeref:typename:int	access:public	signature:()
CgenNode::basic_status	cgen.h	/^		Basicness basic_status;                    \/\/ `Basic' if class is basic$/;"	m	class:CgenNode	typeref:typename:Basicness	access:private
CgenNode::children	cgen.h	/^		List<CgenNode> *children;                  \/\/ Children of class$/;"	m	class:CgenNode	typeref:typename:List<CgenNode> *	access:private
CgenNode::code_dispTab	cgen.cc	/^void CgenNode::code_dispTab(std::vector<std::pair<Symbol, Symbol>> mp, ostream &s)$/;"	f	class:CgenNode	typeref:typename:void	signature:(std::vector<std::pair<Symbol,Symbol>> mp,ostream & s)
CgenNode::code_dispTab	cgen.h	/^		void code_dispTab(std::vector<std::pair<Symbol, Symbol>>, ostream &);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(std::vector<std::pair<Symbol,Symbol>>,ostream &)
CgenNode::code_init	cgen.cc	/^void CgenNode::code_init(ostream &s) {$/;"	f	class:CgenNode	typeref:typename:void	signature:(ostream & s)
CgenNode::code_init	cgen.h	/^		void code_init(ostream &);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(ostream &)
CgenNode::code_method	cgen.cc	/^void CgenNode::code_method(ostream &s) {$/;"	f	class:CgenNode	typeref:typename:void	signature:(ostream & s)
CgenNode::code_method	cgen.h	/^		void code_method(ostream &);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(ostream &)
CgenNode::code_nameTab	cgen.cc	/^void CgenNode::code_nameTab(int &nodesize, ostream &s)$/;"	f	class:CgenNode	typeref:typename:void	signature:(int & nodesize,ostream & s)
CgenNode::code_nameTab	cgen.h	/^		void code_nameTab(int &, ostream &);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(int &,ostream &)
CgenNode::code_objTab	cgen.cc	/^void CgenNode::code_objTab(ostream &s)$/;"	f	class:CgenNode	typeref:typename:void	signature:(ostream & s)
CgenNode::code_objTab	cgen.h	/^		void code_objTab(ostream &);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(ostream &)
CgenNode::code_protObj	cgen.cc	/^void CgenNode::code_protObj(std::vector<Symbol> mp, ostream &s) {$/;"	f	class:CgenNode	typeref:typename:void	signature:(std::vector<Symbol> mp,ostream & s)
CgenNode::code_protObj	cgen.h	/^		void code_protObj(std::vector<Symbol>, ostream &);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(std::vector<Symbol>,ostream &)
CgenNode::find_method	cgen.cc	/^method_class *CgenNode::find_method(Symbol method_name) {$/;"	f	class:CgenNode	typeref:typename:method_class *	signature:(Symbol method_name)
CgenNode::find_method	cgen.h	/^		method_class *find_method(Symbol);$/;"	p	class:CgenNode	typeref:typename:method_class *	access:public	signature:(Symbol)
CgenNode::get_children	cgen.h	/^		List<CgenNode> *get_children() { return children; }$/;"	f	class:CgenNode	typeref:typename:List<CgenNode> *	access:public	signature:()
CgenNode::get_parentnd	cgen.h	/^		CgenNodeP get_parentnd() { return parentnd; }$/;"	f	class:CgenNode	typeref:typename:CgenNodeP	access:public	signature:()
CgenNode::install_args	cgen.h	/^		void install_args(Symbol);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(Symbol)
CgenNode::method_index	cgen.h	/^		std::map<Symbol, int> method_index;$/;"	m	class:CgenNode	typeref:typename:std::map<Symbol,int>	access:public
CgenNode::parentnd	cgen.h	/^		CgenNodeP parentnd;                        \/\/ Parent of class$/;"	m	class:CgenNode	typeref:typename:CgenNodeP	access:private
CgenNode::set_parentnd	cgen.cc	/^void CgenNode::set_parentnd(CgenNodeP p)$/;"	f	class:CgenNode	typeref:typename:void	signature:(CgenNodeP p)
CgenNode::set_parentnd	cgen.h	/^		void set_parentnd(CgenNodeP p);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(CgenNodeP p)
CgenNode::tag	cgen.h	/^		int tag;$/;"	m	class:CgenNode	typeref:typename:int	access:public
CgenNodeP	cgen.h	/^typedef CgenNode *CgenNodeP;$/;"	t	typeref:typename:CgenNode *
Class_	ast-parse.h	/^typedef class Class__class *Class_;$/;"	t	typeref:class:Class__class *
Class_	cool-parse.h	/^typedef class Class__class *Class_;$/;"	t	typeref:class:Class__class *
Class_	cool-tree.h	/^typedef class Class__class *Class_;$/;"	t	typeref:class:Class__class *
Class_	cool-tree.handcode.h	/^typedef Class__class *Class_;$/;"	t	typeref:typename:Class__class *
Class__EXTRAS	cool-tree.handcode.h	/^#define Class__EXTRAS /;"	d
Class__class	cool-tree.h	/^class Class__class : public tree_node {$/;"	c	inherits:tree_node
Class__class::copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Class_(); }$/;"	f	class:Class__class	typeref:typename:tree_node *	access:public	signature:()
Class__class::copy_Class_	cool-tree.h	/^   virtual Class_ copy_Class_() = 0;$/;"	p	class:Class__class	typeref:typename:Class_	access:public	signature:()
Classes	ast-parse.h	/^typedef Classes_class *Classes;$/;"	t	typeref:typename:Classes_class *
Classes	cool-parse.h	/^typedef Classes_class *Classes;$/;"	t	typeref:typename:Classes_class *
Classes	cool-tree.h	/^typedef Classes_class *Classes;$/;"	t	typeref:typename:Classes_class *
Classes	cool-tree.handcode.h	/^typedef Classes_class *Classes;$/;"	t	typeref:typename:Classes_class *
Classes_class	ast-parse.h	/^typedef list_node<Class_> Classes_class;$/;"	t	typeref:typename:list_node<Class_>
Classes_class	cool-parse.h	/^typedef list_node<Class_> Classes_class;$/;"	t	typeref:typename:list_node<Class_>
Classes_class	cool-tree.h	/^typedef list_node<Class_> Classes_class;$/;"	t	typeref:typename:list_node<Class_>
Classes_class	cool-tree.handcode.h	/^typedef list_node<Class_> Classes_class;$/;"	t	typeref:typename:list_node<Class_>
DARROW	cool-parse.h	/^     DARROW = 272,$/;"	e	enum:yytokentype	access:public
DARROW	cool-parse.h	/^#define DARROW /;"	d
DEFAULT_OBJFIELDS	emit.h	/^#define DEFAULT_OBJFIELDS /;"	d
DEPEND	Makefile	/^DEPEND = ${CC} -MM ${CPPINCLUDE}$/;"	m
DISPATCH	ast-parse.cc	/^     DISPATCH = 266,$/;"	e	enum:yytokentype	file:	access:public
DISPATCH	ast-parse.cc	/^#define DISPATCH /;"	d	file:
DISPATCH	ast-parse.h	/^     DISPATCH = 266,$/;"	e	enum:yytokentype	access:public
DISPATCH	ast-parse.h	/^#define DISPATCH /;"	d
DISPTABLE_OFFSET	emit.h	/^#define DISPTABLE_OFFSET /;"	d
DISPTAB_SUFFIX	emit.h	/^#define DISPTAB_SUFFIX /;"	d
DIV	emit.h	/^#define DIV /;"	d
DIVIDE	ast-parse.cc	/^     DIVIDE = 275,$/;"	e	enum:yytokentype	file:	access:public
DIVIDE	ast-parse.cc	/^#define DIVIDE /;"	d	file:
DIVIDE	ast-parse.h	/^     DIVIDE = 275,$/;"	e	enum:yytokentype	access:public
DIVIDE	ast-parse.h	/^#define DIVIDE /;"	d
ECHO	ast-lex.cc	/^#define ECHO /;"	d	file:
ELSE	cool-parse.h	/^     ELSE = 259,$/;"	e	enum:yytokentype	access:public
ELSE	cool-parse.h	/^#define ELSE /;"	d
EMPTYSLOT	emit.h	/^#define EMPTYSLOT /;"	d
EOB_ACT_CONTINUE_SCAN	ast-lex.cc	/^#define EOB_ACT_CONTINUE_SCAN /;"	d	file:
EOB_ACT_END_OF_FILE	ast-lex.cc	/^#define EOB_ACT_END_OF_FILE /;"	d	file:
EOB_ACT_LAST_MATCH	ast-lex.cc	/^#define EOB_ACT_LAST_MATCH /;"	d	file:
EQ	ast-parse.cc	/^     EQ = 278,$/;"	e	enum:yytokentype	file:	access:public
EQ	ast-parse.cc	/^#define EQ /;"	d	file:
EQ	ast-parse.h	/^     EQ = 278,$/;"	e	enum:yytokentype	access:public
EQ	ast-parse.h	/^#define EQ /;"	d
ERROR	cool-parse.h	/^     ERROR = 283,$/;"	e	enum:yytokentype	access:public
ERROR	cool-parse.h	/^#define ERROR /;"	d
ESAC	cool-parse.h	/^     ESAC = 270,$/;"	e	enum:yytokentype	access:public
ESAC	cool-parse.h	/^#define ESAC /;"	d
Entry	stringtab.cc	/^Entry::Entry(char *s, int l, int i) : len(l), index(i) {$/;"	f	class:Entry	signature:(char * s,int l,int i)
Entry	stringtab.h	/^		Entry(char *s, int l, int i);$/;"	p	class:Entry	access:public	signature:(char * s,int l,int i)
Entry	stringtab.h	/^class Entry {$/;"	c
Entry::Entry	stringtab.cc	/^Entry::Entry(char *s, int l, int i) : len(l), index(i) {$/;"	f	class:Entry	signature:(char * s,int l,int i)
Entry::Entry	stringtab.h	/^		Entry(char *s, int l, int i);$/;"	p	class:Entry	access:public	signature:(char * s,int l,int i)
Entry::equal_index	stringtab.h	/^		bool equal_index(int ind) const           { return ind == index; }$/;"	f	class:Entry	typeref:typename:bool	access:public	signature:(int ind) const
Entry::equal_string	stringtab.cc	/^int Entry::equal_string(char *string, int length) const$/;"	f	class:Entry	typeref:typename:int	signature:(char * string,int length) const
Entry::equal_string	stringtab.h	/^		int equal_string(char *s, int len) const;  $/;"	p	class:Entry	typeref:typename:int	access:public	signature:(char * s,int len) const
Entry::get_len	stringtab.cc	/^int Entry::get_len() const$/;"	f	class:Entry	typeref:typename:int	signature:() const
Entry::get_len	stringtab.h	/^		int get_len() const;$/;"	p	class:Entry	typeref:typename:int	access:public	signature:() const
Entry::get_string	stringtab.cc	/^char *Entry::get_string() const$/;"	f	class:Entry	typeref:typename:char *	signature:() const
Entry::get_string	stringtab.h	/^		char *get_string() const;$/;"	p	class:Entry	typeref:typename:char *	access:public	signature:() const
Entry::index	stringtab.h	/^		int index;     \/\/ a unique index for each string$/;"	m	class:Entry	typeref:typename:int	access:protected
Entry::len	stringtab.h	/^		int  len;      \/\/ the length of the string (without trailing \\0)$/;"	m	class:Entry	typeref:typename:int	access:protected
Entry::print	stringtab.cc	/^ostream& Entry::print(ostream& s) const$/;"	f	class:Entry	typeref:typename:ostream &	signature:(ostream & s) const
Entry::print	stringtab.h	/^		ostream& print(ostream& s) const;$/;"	p	class:Entry	typeref:typename:ostream &	access:public	signature:(ostream & s) const
Entry::str	stringtab.h	/^		char *str;     \/\/ the string$/;"	m	class:Entry	typeref:typename:char *	access:protected
Environment	cgen.h	/^		Environment() {$/;"	f	class:Environment	access:public	signature:()
Environment	cgen.h	/^class Environment {$/;"	c
Environment::Environment	cgen.h	/^		Environment() {$/;"	f	class:Environment	access:public	signature:()
Environment::add_Argument	cgen.h	/^		void add_Argument(Symbol s) {$/;"	f	class:Environment	typeref:typename:void	access:public	signature:(Symbol s)
Environment::add_Attribute	cgen.h	/^		void add_Attribute(CgenNodeP p) { attr_index = p->attr_index; }$/;"	f	class:Environment	typeref:typename:void	access:public	signature:(CgenNodeP p)
Environment::add_Variable	cgen.h	/^		void add_Variable(Symbol s, int id) { var_index.addid(s, new int(id)); }$/;"	f	class:Environment	typeref:typename:void	access:public	signature:(Symbol s,int id)
Environment::args_enter	cgen.h	/^		void args_enter() { args_index.enterscope(); }$/;"	f	class:Environment	typeref:typename:void	access:public	signature:()
Environment::args_exit	cgen.h	/^		void args_exit() { args_index.exitscope(); }$/;"	f	class:Environment	typeref:typename:void	access:public	signature:()
Environment::args_index	cgen.h	/^		SymbolTable<Symbol, int> args_index;$/;"	m	class:Environment	typeref:typename:SymbolTable<Symbol,int>	access:public
Environment::args_size	cgen.h	/^		int args_size = 0, var_scopes = 0;$/;"	m	class:Environment	typeref:typename:int	access:public
Environment::attr_index	cgen.h	/^		std::map<Symbol, int> attr_index;$/;"	m	class:Environment	typeref:typename:std::map<Symbol,int>	access:public
Environment::get_Argument	cgen.h	/^		int get_Argument(Symbol s) {$/;"	f	class:Environment	typeref:typename:int	access:public	signature:(Symbol s)
Environment::get_Attribute	cgen.h	/^		int get_Attribute(Symbol s) {$/;"	f	class:Environment	typeref:typename:int	access:public	signature:(Symbol s)
Environment::get_Var	cgen.h	/^		int get_Var(Symbol s) {$/;"	f	class:Environment	typeref:typename:int	access:public	signature:(Symbol s)
Environment::var_exit	cgen.h	/^		void var_exit() { var_index.exitscope(); }$/;"	f	class:Environment	typeref:typename:void	access:public	signature:()
Environment::var_index	cgen.h	/^		SymbolTable<Symbol, int> var_index;$/;"	m	class:Environment	typeref:typename:SymbolTable<Symbol,int>	access:public
Environment::var_scopes	cgen.h	/^		int args_size = 0, var_scopes = 0;$/;"	m	class:Environment	typeref:typename:int	access:public
Environment::vars_dump	cgen.h	/^		void vars_dump() {$/;"	f	class:Environment	typeref:typename:void	access:public	signature:()
Environment::vars_enter	cgen.h	/^		void vars_enter() {$/;"	f	class:Environment	typeref:typename:void	access:public	signature:()
Expression	ast-parse.h	/^typedef class Expression_class *Expression;$/;"	t	typeref:class:Expression_class *
Expression	cool-parse.h	/^typedef class Expression_class *Expression;$/;"	t	typeref:class:Expression_class *
Expression	cool-tree.h	/^typedef class Expression_class *Expression;$/;"	t	typeref:class:Expression_class *
Expression	cool-tree.handcode.h	/^typedef Expression_class *Expression;$/;"	t	typeref:typename:Expression_class *
Expression_EXTRAS	cool-tree.handcode.h	/^#define Expression_EXTRAS /;"	d
Expression_SHARED_EXTRAS	cool-tree.handcode.h	/^#define Expression_SHARED_EXTRAS /;"	d
Expression_class	cool-tree.h	/^class Expression_class : public tree_node {$/;"	c	inherits:tree_node
Expression_class::copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Expression(); }$/;"	f	class:Expression_class	typeref:typename:tree_node *	access:public	signature:()
Expression_class::copy_Expression	cool-tree.h	/^   virtual Expression copy_Expression() = 0;$/;"	p	class:Expression_class	typeref:typename:Expression	access:public	signature:()
Expression_class::dump_type	dumptype.cc	/^void Expression_class::dump_type(ostream& stream, int n)$/;"	f	class:Expression_class	typeref:typename:void	signature:(ostream & stream,int n)
Expressions	ast-parse.h	/^typedef Expressions_class *Expressions;$/;"	t	typeref:typename:Expressions_class *
Expressions	cool-parse.h	/^typedef Expressions_class *Expressions;$/;"	t	typeref:typename:Expressions_class *
Expressions	cool-tree.h	/^typedef Expressions_class *Expressions;$/;"	t	typeref:typename:Expressions_class *
Expressions	cool-tree.handcode.h	/^typedef Expressions_class *Expressions;$/;"	t	typeref:typename:Expressions_class *
Expressions_class	ast-parse.h	/^typedef list_node<Expression> Expressions_class;$/;"	t	typeref:typename:list_node<Expression>
Expressions_class	cool-parse.h	/^typedef list_node<Expression> Expressions_class;$/;"	t	typeref:typename:list_node<Expression>
Expressions_class	cool-tree.h	/^typedef list_node<Expression> Expressions_class;$/;"	t	typeref:typename:list_node<Expression>
Expressions_class	cool-tree.handcode.h	/^typedef list_node<Expression> Expressions_class;$/;"	t	typeref:typename:list_node<Expression>
FALSE	cgen.h	/^#define FALSE /;"	d
FFLAGS	Makefile	/^FFLAGS = -d8 -ocool-lex.cc$/;"	m
FI	cool-parse.h	/^     FI = 260,$/;"	e	enum:yytokentype	access:public
FI	cool-parse.h	/^#define FI /;"	d
FLEX	Makefile	/^FLEX=flex ${FFLAGS}$/;"	m
FLEXINT_H	ast-lex.cc	/^#define FLEXINT_H$/;"	d	file:
FLEX_BETA	ast-lex.cc	/^#define FLEX_BETA$/;"	d	file:
FLEX_DEBUG	ast-lex.cc	/^#define FLEX_DEBUG$/;"	d	file:
FLEX_SCANNER	ast-lex.cc	/^#define FLEX_SCANNER$/;"	d	file:
FORMAL	ast-parse.cc	/^     FORMAL = 262,$/;"	e	enum:yytokentype	file:	access:public
FORMAL	ast-parse.cc	/^#define FORMAL /;"	d	file:
FORMAL	ast-parse.h	/^     FORMAL = 262,$/;"	e	enum:yytokentype	access:public
FORMAL	ast-parse.h	/^#define FORMAL /;"	d
FP	emit.h	/^#define FP /;"	d
Feature	ast-parse.h	/^typedef class Feature_class *Feature;$/;"	t	typeref:class:Feature_class *
Feature	cool-parse.h	/^typedef class Feature_class *Feature;$/;"	t	typeref:class:Feature_class *
Feature	cool-tree.h	/^typedef class Feature_class *Feature;$/;"	t	typeref:class:Feature_class *
Feature	cool-tree.handcode.h	/^typedef Feature_class *Feature;$/;"	t	typeref:typename:Feature_class *
Feature_EXTRAS	cool-tree.handcode.h	/^#define Feature_EXTRAS /;"	d
Feature_SHARED_EXTRAS	cool-tree.handcode.h	/^#define Feature_SHARED_EXTRAS /;"	d
Feature_class	cool-tree.h	/^class Feature_class : public tree_node {$/;"	c	inherits:tree_node
Feature_class::copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Feature(); }$/;"	f	class:Feature_class	typeref:typename:tree_node *	access:public	signature:()
Feature_class::copy_Feature	cool-tree.h	/^   virtual Feature copy_Feature() = 0;$/;"	p	class:Feature_class	typeref:typename:Feature	access:public	signature:()
Features	ast-parse.h	/^typedef Features_class *Features;$/;"	t	typeref:typename:Features_class *
Features	cool-parse.h	/^typedef Features_class *Features;$/;"	t	typeref:typename:Features_class *
Features	cool-tree.h	/^typedef Features_class *Features;$/;"	t	typeref:typename:Features_class *
Features	cool-tree.handcode.h	/^typedef Features_class *Features;$/;"	t	typeref:typename:Features_class *
Features_class	ast-parse.h	/^typedef list_node<Feature> Features_class;$/;"	t	typeref:typename:list_node<Feature>
Features_class	cool-parse.h	/^typedef list_node<Feature> Features_class;$/;"	t	typeref:typename:list_node<Feature>
Features_class	cool-tree.h	/^typedef list_node<Feature> Features_class;$/;"	t	typeref:typename:list_node<Feature>
Features_class	cool-tree.handcode.h	/^typedef list_node<Feature> Features_class;$/;"	t	typeref:typename:list_node<Feature>
Formal	ast-parse.h	/^typedef class Formal_class *Formal;$/;"	t	typeref:class:Formal_class *
Formal	cool-parse.h	/^typedef class Formal_class *Formal;$/;"	t	typeref:class:Formal_class *
Formal	cool-tree.h	/^typedef class Formal_class *Formal;$/;"	t	typeref:class:Formal_class *
Formal	cool-tree.handcode.h	/^typedef Formal_class *Formal;$/;"	t	typeref:typename:Formal_class *
Formal_EXTRAS	cool-tree.handcode.h	/^#define Formal_EXTRAS /;"	d
Formal_class	cool-tree.h	/^class Formal_class : public tree_node {$/;"	c	inherits:tree_node
Formal_class::copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Formal(); }$/;"	f	class:Formal_class	typeref:typename:tree_node *	access:public	signature:()
Formal_class::copy_Formal	cool-tree.h	/^   virtual Formal copy_Formal() = 0;$/;"	p	class:Formal_class	typeref:typename:Formal	access:public	signature:()
Formals	ast-parse.h	/^typedef Formals_class *Formals;$/;"	t	typeref:typename:Formals_class *
Formals	cool-parse.h	/^typedef Formals_class *Formals;$/;"	t	typeref:typename:Formals_class *
Formals	cool-tree.h	/^typedef Formals_class *Formals;$/;"	t	typeref:typename:Formals_class *
Formals	cool-tree.handcode.h	/^typedef Formals_class *Formals;$/;"	t	typeref:typename:Formals_class *
Formals_class	ast-parse.h	/^typedef list_node<Formal> Formals_class;$/;"	t	typeref:typename:list_node<Formal>
Formals_class	cool-parse.h	/^typedef list_node<Formal> Formals_class;$/;"	t	typeref:typename:list_node<Formal>
Formals_class	cool-tree.h	/^typedef list_node<Formal> Formals_class;$/;"	t	typeref:typename:list_node<Formal>
Formals_class	cool-tree.handcode.h	/^typedef list_node<Formal> Formals_class;$/;"	t	typeref:typename:list_node<Formal>
GC_DEBUG	cgen_gc.h	/^extern enum Memmgr_Debug { GC_QUICK, GC_DEBUG } cgen_Memmgr_Debug;$/;"	e	enum:Memmgr_Debug	access:public
GC_GENGC	cgen_gc.h	/^extern enum Memmgr { GC_NOGC, GC_GENGC, GC_SNCGC } cgen_Memmgr;$/;"	e	enum:Memmgr	access:public
GC_NOGC	cgen_gc.h	/^extern enum Memmgr { GC_NOGC, GC_GENGC, GC_SNCGC } cgen_Memmgr;$/;"	e	enum:Memmgr	access:public
GC_NORMAL	cgen_gc.h	/^extern enum Memmgr_Test { GC_NORMAL, GC_TEST } cgen_Memmgr_Test;$/;"	e	enum:Memmgr_Test	access:public
GC_QUICK	cgen_gc.h	/^extern enum Memmgr_Debug { GC_QUICK, GC_DEBUG } cgen_Memmgr_Debug;$/;"	e	enum:Memmgr_Debug	access:public
GC_SNCGC	cgen_gc.h	/^extern enum Memmgr { GC_NOGC, GC_GENGC, GC_SNCGC } cgen_Memmgr;$/;"	e	enum:Memmgr	access:public
GC_TEST	cgen_gc.h	/^extern enum Memmgr_Test { GC_NORMAL, GC_TEST } cgen_Memmgr_Test;$/;"	e	enum:Memmgr_Test	access:public
GLOBAL	emit.h	/^#define GLOBAL /;"	d
HEAP_START	emit.h	/^#define HEAP_START /;"	d
HGEN	Makefile	/^HGEN= $/;"	m
ID	ast-parse.cc	/^     ID = 291,$/;"	e	enum:yytokentype	file:	access:public
ID	ast-parse.cc	/^#define ID /;"	d	file:
ID	ast-parse.h	/^     ID = 291,$/;"	e	enum:yytokentype	access:public
ID	ast-parse.h	/^#define ID /;"	d
IF	cool-parse.h	/^     IF = 261,$/;"	e	enum:yytokentype	access:public
IF	cool-parse.h	/^#define IF /;"	d
IN	cool-parse.h	/^     IN = 262,$/;"	e	enum:yytokentype	access:public
IN	cool-parse.h	/^#define IN /;"	d
INHERITS	cool-parse.h	/^     INHERITS = 263,$/;"	e	enum:yytokentype	access:public
INHERITS	cool-parse.h	/^#define INHERITS /;"	d
INITIAL	ast-lex.cc	/^#define INITIAL /;"	d	file:
INT	ast-parse.cc	/^     INT = 281,$/;"	e	enum:yytokentype	file:	access:public
INT	ast-parse.cc	/^#define INT /;"	d	file:
INT	ast-parse.h	/^     INT = 281,$/;"	e	enum:yytokentype	access:public
INT	ast-parse.h	/^#define INT /;"	d
INT16_MAX	ast-lex.cc	/^#define INT16_MAX /;"	d	file:
INT16_MIN	ast-lex.cc	/^#define INT16_MIN /;"	d	file:
INT32_MAX	ast-lex.cc	/^#define INT32_MAX /;"	d	file:
INT32_MIN	ast-lex.cc	/^#define INT32_MIN /;"	d	file:
INT8_MAX	ast-lex.cc	/^#define INT8_MAX /;"	d	file:
INT8_MIN	ast-lex.cc	/^#define INT8_MIN /;"	d	file:
INTCONST_PREFIX	emit.h	/^#define INTCONST_PREFIX /;"	d
INTNAME	emit.h	/^#define INTNAME /;"	d
INTTAG	emit.h	/^#define INTTAG /;"	d
INT_CONST	ast-parse.cc	/^     INT_CONST = 290,$/;"	e	enum:yytokentype	file:	access:public
INT_CONST	ast-parse.cc	/^#define INT_CONST /;"	d	file:
INT_CONST	ast-parse.h	/^     INT_CONST = 290,$/;"	e	enum:yytokentype	access:public
INT_CONST	ast-parse.h	/^#define INT_CONST /;"	d
INT_CONST	cool-parse.h	/^     INT_CONST = 276,$/;"	e	enum:yytokentype	access:public
INT_CONST	cool-parse.h	/^#define INT_CONST /;"	d
INT_SLOTS	emit.h	/^#define INT_SLOTS /;"	d
IO	cgen.cc	/^	IO,$/;"	v	typeref:typename:Symbol
ISVOID	ast-parse.cc	/^     ISVOID = 285,$/;"	e	enum:yytokentype	file:	access:public
ISVOID	ast-parse.cc	/^#define ISVOID /;"	d	file:
ISVOID	ast-parse.h	/^     ISVOID = 285,$/;"	e	enum:yytokentype	access:public
ISVOID	ast-parse.h	/^#define ISVOID /;"	d
ISVOID	cool-parse.h	/^     ISVOID = 274,$/;"	e	enum:yytokentype	access:public
ISVOID	cool-parse.h	/^#define ISVOID /;"	d
IdEntry	stringtab.cc	/^IdEntry::IdEntry(char *s, int l, int i) : Entry(s,l,i) { }$/;"	f	class:IdEntry	signature:(char * s,int l,int i)
IdEntry	stringtab.h	/^		IdEntry(char *s, int l, int i);$/;"	p	class:IdEntry	access:public	signature:(char * s,int l,int i)
IdEntry	stringtab.h	/^class IdEntry : public Entry {$/;"	c	inherits:Entry
IdEntry::IdEntry	stringtab.cc	/^IdEntry::IdEntry(char *s, int l, int i) : Entry(s,l,i) { }$/;"	f	class:IdEntry	signature:(char * s,int l,int i)
IdEntry::IdEntry	stringtab.h	/^		IdEntry(char *s, int l, int i);$/;"	p	class:IdEntry	access:public	signature:(char * s,int l,int i)
IdEntryP	stringtab.h	/^typedef IdEntry *IdEntryP;$/;"	t	typeref:typename:IdEntry *
IdTable	stringtab.h	/^class IdTable : public StringTable<IdEntry> { };$/;"	c	inherits:StringTable<IdEntry>
Int	cgen.cc	/^	Int,$/;"	v	typeref:typename:Symbol
IntEntry	stringtab.cc	/^IntEntry::IntEntry(char *s, int l, int i) : Entry(s,l,i) { }$/;"	f	class:IntEntry	signature:(char * s,int l,int i)
IntEntry	stringtab.h	/^		IntEntry(char *s, int l, int i);$/;"	p	class:IntEntry	access:public	signature:(char * s,int l,int i)
IntEntry	stringtab.h	/^class IntEntry: public Entry {$/;"	c	inherits:Entry
IntEntry::IntEntry	stringtab.cc	/^IntEntry::IntEntry(char *s, int l, int i) : Entry(s,l,i) { }$/;"	f	class:IntEntry	signature:(char * s,int l,int i)
IntEntry::IntEntry	stringtab.h	/^		IntEntry(char *s, int l, int i);$/;"	p	class:IntEntry	access:public	signature:(char * s,int l,int i)
IntEntry::code_def	cgen.cc	/^void IntEntry::code_def(ostream &s, int intclasstag)$/;"	f	class:IntEntry	typeref:typename:void	signature:(ostream & s,int intclasstag)
IntEntry::code_def	stringtab.h	/^		void code_def(ostream& str, int intclasstag);$/;"	p	class:IntEntry	typeref:typename:void	access:public	signature:(ostream & str,int intclasstag)
IntEntry::code_ref	cgen.cc	/^void IntEntry::code_ref(ostream &s)$/;"	f	class:IntEntry	typeref:typename:void	signature:(ostream & s)
IntEntry::code_ref	stringtab.h	/^		void code_ref(ostream& str);$/;"	p	class:IntEntry	typeref:typename:void	access:public	signature:(ostream & str)
IntEntryP	stringtab.h	/^typedef IntEntry *IntEntryP;$/;"	t	typeref:typename:IntEntry *
IntTable	stringtab.h	/^class IntTable : public StringTable<IntEntry>$/;"	c	inherits:StringTable<IntEntry>
IntTable::code_string_table	cgen.cc	/^void IntTable::code_string_table(ostream &s, int intclasstag)$/;"	f	class:IntTable	typeref:typename:void	signature:(ostream & s,int intclasstag)
IntTable::code_string_table	stringtab.h	/^		void code_string_table(ostream&, int classtag);$/;"	p	class:IntTable	typeref:typename:void	access:public	signature:(ostream &,int classtag)
JAL	emit.h	/^#define JAL /;"	d
JALR	emit.h	/^#define JALR /;"	d
LA	emit.h	/^#define LA /;"	d
LABEL	emit.h	/^#define LABEL /;"	d
LE	cool-parse.h	/^     LE = 282,$/;"	e	enum:yytokentype	access:public
LE	cool-parse.h	/^#define LE /;"	d
LEQ	ast-parse.cc	/^     LEQ = 279,$/;"	e	enum:yytokentype	file:	access:public
LEQ	ast-parse.cc	/^#define LEQ /;"	d	file:
LEQ	ast-parse.h	/^     LEQ = 279,$/;"	e	enum:yytokentype	access:public
LEQ	ast-parse.h	/^#define LEQ /;"	d
LET	ast-parse.cc	/^     LET = 271,$/;"	e	enum:yytokentype	file:	access:public
LET	ast-parse.cc	/^#define LET /;"	d	file:
LET	ast-parse.h	/^     LET = 271,$/;"	e	enum:yytokentype	access:public
LET	ast-parse.h	/^#define LET /;"	d
LET	cool-parse.h	/^     LET = 264,$/;"	e	enum:yytokentype	access:public
LET	cool-parse.h	/^#define LET /;"	d
LET_STMT	cool-parse.h	/^     LET_STMT = 285$/;"	e	enum:yytokentype	access:public
LET_STMT	cool-parse.h	/^#define LET_STMT /;"	d
LI	emit.h	/^#define LI /;"	d
LIB	Makefile	/^LIB= -L\/usr\/pubsw\/lib -lfl $/;"	m
LIBS	Makefile	/^LIBS= lexer parser semant$/;"	m
LINENO	ast-parse.cc	/^     LINENO = 292$/;"	e	enum:yytokentype	file:	access:public
LINENO	ast-parse.cc	/^#define LINENO /;"	d	file:
LINENO	ast-parse.h	/^     LINENO = 292$/;"	e	enum:yytokentype	access:public
LINENO	ast-parse.h	/^#define LINENO /;"	d
LOG_WORD_SIZE	emit.h	/^#define LOG_WORD_SIZE /;"	d
LOOP	ast-parse.cc	/^     LOOP = 268,$/;"	e	enum:yytokentype	file:	access:public
LOOP	ast-parse.cc	/^#define LOOP /;"	d	file:
LOOP	ast-parse.h	/^     LOOP = 268,$/;"	e	enum:yytokentype	access:public
LOOP	ast-parse.h	/^#define LOOP /;"	d
LOOP	cool-parse.h	/^     LOOP = 265,$/;"	e	enum:yytokentype	access:public
LOOP	cool-parse.h	/^#define LOOP /;"	d
LSRC	Makefile	/^LSRC= Makefile$/;"	m
LT	ast-parse.cc	/^     LT = 277,$/;"	e	enum:yytokentype	file:	access:public
LT	ast-parse.cc	/^#define LT /;"	d	file:
LT	ast-parse.h	/^     LT = 277,$/;"	e	enum:yytokentype	access:public
LT	ast-parse.h	/^#define LT /;"	d
LW	emit.h	/^#define LW /;"	d
List	list.h	/^  List(T *h,List<T>* t = NULL): head(h), tail(t) { }$/;"	f	class:List	access:public	signature:(T * h,List<T> * t=NULL)
List	list.h	/^class List {$/;"	c
List::List	list.h	/^  List(T *h,List<T>* t = NULL): head(h), tail(t) { }$/;"	f	class:List	access:public	signature:(T * h,List<T> * t=NULL)
List::hd	list.h	/^  T *hd() const       { return head; }  $/;"	f	class:List	typeref:typename:T *	access:public	signature:() const
List::head	list.h	/^  T *head;$/;"	m	class:List	typeref:typename:T *	access:private
List::tail	list.h	/^  List<T>* tail;$/;"	m	class:List	typeref:typename:List<T> *	access:private
List::tl	list.h	/^  List<T>* tl() const { return tail; }$/;"	f	class:List	typeref:typename:List<T> *	access:public	signature:() const
MAINNAME	emit.h	/^#define MAINNAME /;"	d
MAXINT	emit.h	/^#define MAXINT /;"	d
MAXSIZE	stringtab_functions.h	/^#define MAXSIZE /;"	d
MAX_STR_CONST	ast-lex.cc	/^#define MAX_STR_CONST /;"	d	file:
METHOD	ast-parse.cc	/^     METHOD = 260,$/;"	e	enum:yytokentype	file:	access:public
METHOD	ast-parse.cc	/^#define METHOD /;"	d	file:
METHOD	ast-parse.h	/^     METHOD = 260,$/;"	e	enum:yytokentype	access:public
METHOD	ast-parse.h	/^#define METHOD /;"	d
METHOD_SEP	emit.h	/^#define METHOD_SEP /;"	d
MOVE	emit.h	/^#define MOVE /;"	d
MUL	ast-parse.cc	/^     MUL = 274,$/;"	e	enum:yytokentype	file:	access:public
MUL	ast-parse.cc	/^#define MUL /;"	d	file:
MUL	ast-parse.h	/^     MUL = 274,$/;"	e	enum:yytokentype	access:public
MUL	ast-parse.h	/^#define MUL /;"	d
MUL	emit.h	/^#define MUL /;"	d
Main	cgen.cc	/^	Main,$/;"	v	typeref:typename:Symbol
Memmgr	cgen_gc.h	/^extern enum Memmgr { GC_NOGC, GC_GENGC, GC_SNCGC } cgen_Memmgr;$/;"	g
Memmgr_Debug	cgen_gc.h	/^extern enum Memmgr_Debug { GC_QUICK, GC_DEBUG } cgen_Memmgr_Debug;$/;"	g
Memmgr_Test	cgen_gc.h	/^extern enum Memmgr_Test { GC_NORMAL, GC_TEST } cgen_Memmgr_Test;$/;"	g
NEG	ast-parse.cc	/^     NEG = 276,$/;"	e	enum:yytokentype	file:	access:public
NEG	ast-parse.cc	/^#define NEG /;"	d	file:
NEG	ast-parse.h	/^     NEG = 276,$/;"	e	enum:yytokentype	access:public
NEG	ast-parse.h	/^#define NEG /;"	d
NEG	emit.h	/^#define NEG /;"	d
NEW	ast-parse.cc	/^     NEW = 284,$/;"	e	enum:yytokentype	file:	access:public
NEW	ast-parse.cc	/^#define NEW /;"	d	file:
NEW	ast-parse.h	/^     NEW = 284,$/;"	e	enum:yytokentype	access:public
NEW	ast-parse.h	/^#define NEW /;"	d
NEW	cool-parse.h	/^     NEW = 273,$/;"	e	enum:yytokentype	access:public
NEW	cool-parse.h	/^#define NEW /;"	d
NOT	cool-parse.h	/^     NOT = 281,$/;"	e	enum:yytokentype	access:public
NOT	cool-parse.h	/^#define NOT /;"	d
NO_EXPR	ast-parse.cc	/^     NO_EXPR = 286,$/;"	e	enum:yytokentype	file:	access:public
NO_EXPR	ast-parse.cc	/^#define NO_EXPR /;"	d	file:
NO_EXPR	ast-parse.h	/^     NO_EXPR = 286,$/;"	e	enum:yytokentype	access:public
NO_EXPR	ast-parse.h	/^#define NO_EXPR /;"	d
NO_TYPE	ast-parse.cc	/^     NO_TYPE = 288,$/;"	e	enum:yytokentype	file:	access:public
NO_TYPE	ast-parse.cc	/^#define NO_TYPE /;"	d	file:
NO_TYPE	ast-parse.h	/^     NO_TYPE = 288,$/;"	e	enum:yytokentype	access:public
NO_TYPE	ast-parse.h	/^#define NO_TYPE /;"	d
No_class	cgen.cc	/^	No_class,$/;"	v	typeref:typename:Symbol
No_type	cgen.cc	/^	No_type,$/;"	v	typeref:typename:Symbol
NotBasic	cgen.h	/^enum Basicness     {Basic, NotBasic};$/;"	e	enum:Basicness	access:public
OBJECT	ast-parse.cc	/^     OBJECT = 287,$/;"	e	enum:yytokentype	file:	access:public
OBJECT	ast-parse.cc	/^#define OBJECT /;"	d	file:
OBJECT	ast-parse.h	/^     OBJECT = 287,$/;"	e	enum:yytokentype	access:public
OBJECT	ast-parse.h	/^#define OBJECT /;"	d
OBJECTID	cool-parse.h	/^     OBJECTID = 279,$/;"	e	enum:yytokentype	access:public
OBJECTID	cool-parse.h	/^#define OBJECTID /;"	d
OBJECTPROTOBJ	emit.h	/^#define OBJECTPROTOBJ /;"	d
OBJS	Makefile	/^OBJS= ${CFIL:.cc=.o}$/;"	m
OF	cool-parse.h	/^     OF = 271,$/;"	e	enum:yytokentype	access:public
OF	cool-parse.h	/^#define OF /;"	d
OUTPUT	Makefile	/^OUTPUT= good.output bad.output$/;"	m
Object	cgen.cc	/^	Object,$/;"	v	typeref:typename:Symbol
PLUS	ast-parse.cc	/^     PLUS = 272,$/;"	e	enum:yytokentype	file:	access:public
PLUS	ast-parse.cc	/^#define PLUS /;"	d	file:
PLUS	ast-parse.h	/^     PLUS = 272,$/;"	e	enum:yytokentype	access:public
PLUS	ast-parse.h	/^#define PLUS /;"	d
POOL	cool-parse.h	/^     POOL = 266,$/;"	e	enum:yytokentype	access:public
POOL	cool-parse.h	/^#define POOL /;"	d
PROGRAM	ast-parse.cc	/^     PROGRAM = 258,$/;"	e	enum:yytokentype	file:	access:public
PROGRAM	ast-parse.cc	/^#define PROGRAM /;"	d	file:
PROGRAM	ast-parse.h	/^     PROGRAM = 258,$/;"	e	enum:yytokentype	access:public
PROGRAM	ast-parse.h	/^#define PROGRAM /;"	d
PROTOBJ_SUFFIX	emit.h	/^#define PROTOBJ_SUFFIX /;"	d
Program	ast-parse.h	/^typedef class Program_class *Program;$/;"	t	typeref:class:Program_class *
Program	cool-parse.h	/^typedef class Program_class *Program;$/;"	t	typeref:class:Program_class *
Program	cool-tree.h	/^typedef class Program_class *Program;$/;"	t	typeref:class:Program_class *
Program	cool-tree.handcode.h	/^typedef Program_class *Program;$/;"	t	typeref:typename:Program_class *
Program_EXTRAS	cool-tree.handcode.h	/^#define Program_EXTRAS /;"	d
Program_class	cool-tree.h	/^class Program_class : public tree_node {$/;"	c	inherits:tree_node
Program_class::copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Program(); }$/;"	f	class:Program_class	typeref:typename:tree_node *	access:public	signature:()
Program_class::copy_Program	cool-tree.h	/^   virtual Program copy_Program() = 0;$/;"	p	class:Program_class	typeref:typename:Program	access:public	signature:()
RA	emit.h	/^#define RA /;"	d
RANLIB	Makefile	/^RANLIB= gar -qs$/;"	m
REJECT	ast-lex.cc	/^#define REJECT /;"	d	file:
RET	emit.h	/^#define RET /;"	d
SELF	emit.h	/^#define SELF /;"	d
SELF_TYPE	cgen.cc	/^	SELF_TYPE,$/;"	v	typeref:typename:Symbol
SIZE_OFFSET	emit.h	/^#define SIZE_OFFSET /;"	d
SLL	emit.h	/^#define SLL /;"	d
SP	emit.h	/^#define SP /;"	d
SRC	Makefile	/^SRC= cgen.cc cgen.h cgen_supp.cc cool-tree.h cool-tree.handcode.h emit.h example.cl README$/;"	m
STATIC_DISPATCH	ast-parse.cc	/^     STATIC_DISPATCH = 265,$/;"	e	enum:yytokentype	file:	access:public
STATIC_DISPATCH	ast-parse.cc	/^#define STATIC_DISPATCH /;"	d	file:
STATIC_DISPATCH	ast-parse.h	/^     STATIC_DISPATCH = 265,$/;"	e	enum:yytokentype	access:public
STATIC_DISPATCH	ast-parse.h	/^#define STATIC_DISPATCH /;"	d
STR	ast-parse.cc	/^     STR = 282,$/;"	e	enum:yytokentype	file:	access:public
STR	ast-parse.cc	/^#define STR /;"	d	file:
STR	ast-parse.h	/^     STR = 282,$/;"	e	enum:yytokentype	access:public
STR	ast-parse.h	/^#define STR /;"	d
STRCONST_PREFIX	emit.h	/^#define STRCONST_PREFIX /;"	d
STRING	ast-lex.cc	/^#define STRING /;"	d	file:
STRINGNAME	emit.h	/^#define STRINGNAME /;"	d
STRINGTAG	emit.h	/^#define STRINGTAG /;"	d
STRING_SLOTS	emit.h	/^#define STRING_SLOTS /;"	d
STR_CONST	ast-parse.cc	/^     STR_CONST = 289,$/;"	e	enum:yytokentype	file:	access:public
STR_CONST	ast-parse.cc	/^#define STR_CONST /;"	d	file:
STR_CONST	ast-parse.h	/^     STR_CONST = 289,$/;"	e	enum:yytokentype	access:public
STR_CONST	ast-parse.h	/^#define STR_CONST /;"	d
STR_CONST	cool-parse.h	/^     STR_CONST = 275,$/;"	e	enum:yytokentype	access:public
STR_CONST	cool-parse.h	/^#define STR_CONST /;"	d
SUB	ast-parse.cc	/^     SUB = 273,$/;"	e	enum:yytokentype	file:	access:public
SUB	ast-parse.cc	/^#define SUB /;"	d	file:
SUB	ast-parse.h	/^     SUB = 273,$/;"	e	enum:yytokentype	access:public
SUB	ast-parse.h	/^#define SUB /;"	d
SUB	emit.h	/^#define SUB /;"	d
SW	emit.h	/^#define SW /;"	d
Scope	symtab.h	/^	typedef List<ScopeEntry> Scope;$/;"	t	class:SymbolTable	typeref:typename:List<ScopeEntry>	access:private
ScopeEntry	symtab.h	/^	typedef SymtabEntry<SYM,DAT> ScopeEntry;$/;"	t	class:SymbolTable	typeref:typename:SymtabEntry<SYM,DAT>	access:private
ScopeList	symtab.h	/^	typedef List<Scope> ScopeList;$/;"	t	class:SymbolTable	typeref:typename:List<Scope>	access:private
Str	cgen.cc	/^	Str,$/;"	v	typeref:typename:Symbol
StrTable	stringtab.h	/^class StrTable : public StringTable<StringEntry>$/;"	c	inherits:StringTable<StringEntry>
StrTable::code_string_table	cgen.cc	/^void StrTable::code_string_table(ostream& s, int stringclasstag)$/;"	f	class:StrTable	typeref:typename:void	signature:(ostream & s,int stringclasstag)
StrTable::code_string_table	stringtab.h	/^		void code_string_table(ostream&, int classtag);$/;"	p	class:StrTable	typeref:typename:void	access:public	signature:(ostream &,int classtag)
StringEntry	stringtab.cc	/^StringEntry::StringEntry(char *s, int l, int i) : Entry(s,l,i) { }$/;"	f	class:StringEntry	signature:(char * s,int l,int i)
StringEntry	stringtab.h	/^		StringEntry(char *s, int l, int i);$/;"	p	class:StringEntry	access:public	signature:(char * s,int l,int i)
StringEntry	stringtab.h	/^class StringEntry : public Entry {$/;"	c	inherits:Entry
StringEntry::StringEntry	stringtab.cc	/^StringEntry::StringEntry(char *s, int l, int i) : Entry(s,l,i) { }$/;"	f	class:StringEntry	signature:(char * s,int l,int i)
StringEntry::StringEntry	stringtab.h	/^		StringEntry(char *s, int l, int i);$/;"	p	class:StringEntry	access:public	signature:(char * s,int l,int i)
StringEntry::code_def	cgen.cc	/^void StringEntry::code_def(ostream& s, int stringclasstag)$/;"	f	class:StringEntry	typeref:typename:void	signature:(ostream & s,int stringclasstag)
StringEntry::code_def	stringtab.h	/^		void code_def(ostream& str, int stringclasstag);$/;"	p	class:StringEntry	typeref:typename:void	access:public	signature:(ostream & str,int stringclasstag)
StringEntry::code_ref	cgen.cc	/^void StringEntry::code_ref(ostream& s)$/;"	f	class:StringEntry	typeref:typename:void	signature:(ostream & s)
StringEntry::code_ref	stringtab.h	/^		void code_ref(ostream& str);$/;"	p	class:StringEntry	typeref:typename:void	access:public	signature:(ostream & str)
StringEntryP	stringtab.h	/^typedef StringEntry *StringEntryP;$/;"	t	typeref:typename:StringEntry *
StringTable	stringtab.cc	/^template class StringTable<IdEntry>;$/;"	v	typeref:meta:class
StringTable	stringtab.cc	/^template class StringTable<IntEntry>;$/;"	v	typeref:meta:class
StringTable	stringtab.cc	/^template class StringTable<StringEntry>;$/;"	v	typeref:meta:class
StringTable	stringtab.h	/^		StringTable(): tbl((List<Elem> *) NULL), index(0) { }   \/\/ an empty table$/;"	f	class:StringTable	access:public	signature:()
StringTable	stringtab.h	/^class StringTable$/;"	c
StringTable::StringTable	stringtab.h	/^		StringTable(): tbl((List<Elem> *) NULL), index(0) { }   \/\/ an empty table$/;"	f	class:StringTable	access:public	signature:()
StringTable::add_int	stringtab.h	/^		Elem *add_int(int i);$/;"	p	class:StringTable	typeref:typename:Elem *	access:public	signature:(int i)
StringTable::add_int	stringtab_functions.h	/^Elem *StringTable<Elem>::add_int(int i)$/;"	f	class:StringTable	typeref:typename:Elem *	signature:(int i)
StringTable::add_string	stringtab.h	/^		Elem *add_string(char *s);$/;"	p	class:StringTable	typeref:typename:Elem *	access:public	signature:(char * s)
StringTable::add_string	stringtab.h	/^		Elem *add_string(char *s, int maxchars);$/;"	p	class:StringTable	typeref:typename:Elem *	access:public	signature:(char * s,int maxchars)
StringTable::add_string	stringtab_functions.h	/^Elem *StringTable<Elem>::add_string(char *s)$/;"	f	class:StringTable	typeref:typename:Elem *	signature:(char * s)
StringTable::add_string	stringtab_functions.h	/^Elem *StringTable<Elem>::add_string(char *s, int maxchars)$/;"	f	class:StringTable	typeref:typename:Elem *	signature:(char * s,int maxchars)
StringTable::first	stringtab.h	/^		int first();       \/\/ first index$/;"	p	class:StringTable	typeref:typename:int	access:public	signature:()
StringTable::first	stringtab_functions.h	/^int StringTable<Elem>::first()$/;"	f	class:StringTable	typeref:typename:int	signature:()
StringTable::index	stringtab.h	/^		int index;         \/\/ the current index$/;"	m	class:StringTable	typeref:typename:int	access:protected
StringTable::lookup	stringtab.h	/^		Elem *lookup(int index);      \/\/ lookup an element using its index$/;"	p	class:StringTable	typeref:typename:Elem *	access:public	signature:(int index)
StringTable::lookup	stringtab_functions.h	/^Elem *StringTable<Elem>::lookup(int ind)$/;"	f	class:StringTable	typeref:typename:Elem *	signature:(int ind)
StringTable::lookup_string	stringtab.h	/^		Elem *lookup_string(char *s); \/\/ lookup an element using its string$/;"	p	class:StringTable	typeref:typename:Elem *	access:public	signature:(char * s)
StringTable::lookup_string	stringtab_functions.h	/^Elem *StringTable<Elem>::lookup_string(char *s)$/;"	f	class:StringTable	typeref:typename:Elem *	signature:(char * s)
StringTable::more	stringtab.h	/^		int more(int i);   \/\/ are there more indices?$/;"	p	class:StringTable	typeref:typename:int	access:public	signature:(int i)
StringTable::more	stringtab_functions.h	/^int StringTable<Elem>::more(int i)$/;"	f	class:StringTable	typeref:typename:int	signature:(int i)
StringTable::next	stringtab.h	/^		int next(int i);   \/\/ next index$/;"	p	class:StringTable	typeref:typename:int	access:public	signature:(int i)
StringTable::next	stringtab_functions.h	/^int StringTable<Elem>::next(int i)$/;"	f	class:StringTable	typeref:typename:int	signature:(int i)
StringTable::print	stringtab.h	/^		void print();  \/\/ print the entire table; for debugging$/;"	p	class:StringTable	typeref:typename:void	access:public	signature:()
StringTable::print	stringtab_functions.h	/^void StringTable<Elem>::print()$/;"	f	class:StringTable	typeref:typename:void	signature:()
StringTable::tbl	stringtab.h	/^		List<Elem> *tbl;   \/\/ a string table is a list$/;"	m	class:StringTable	typeref:typename:List<Elem> *	access:protected
Symbol	ast-parse.h	/^typedef Entry *Symbol;$/;"	t	typeref:typename:Entry *
Symbol	cool-parse.h	/^typedef Entry *Symbol;$/;"	t	typeref:typename:Entry *
Symbol	cool.h	/^typedef Entry *Symbol;$/;"	t	typeref:typename:Entry *
Symbol	stringtab.h	/^typedef Entry* Symbol;$/;"	t	typeref:typename:Entry *
SymbolTable	symtab.h	/^	SymbolTable(): tbl(NULL) { }     \/\/ create a new symbol table$/;"	f	class:SymbolTable	access:public	signature:()
SymbolTable	symtab.h	/^class SymbolTable$/;"	c
SymbolTable::Scope	symtab.h	/^	typedef List<ScopeEntry> Scope;$/;"	t	class:SymbolTable	typeref:typename:List<ScopeEntry>	access:private
SymbolTable::ScopeEntry	symtab.h	/^	typedef SymtabEntry<SYM,DAT> ScopeEntry;$/;"	t	class:SymbolTable	typeref:typename:SymtabEntry<SYM,DAT>	access:private
SymbolTable::ScopeList	symtab.h	/^	typedef List<Scope> ScopeList;$/;"	t	class:SymbolTable	typeref:typename:List<Scope>	access:private
SymbolTable::SymbolTable	symtab.h	/^	SymbolTable(): tbl(NULL) { }     \/\/ create a new symbol table$/;"	f	class:SymbolTable	access:public	signature:()
SymbolTable::addid	symtab.h	/^	ScopeEntry *addid(SYM s, DAT *i)$/;"	f	class:SymbolTable	typeref:typename:ScopeEntry *	access:public	signature:(SYM s,DAT * i)
SymbolTable::dump	symtab.h	/^	void dump()$/;"	f	class:SymbolTable	typeref:typename:void	access:public	signature:()
SymbolTable::enterscope	symtab.h	/^	void enterscope()$/;"	f	class:SymbolTable	typeref:typename:void	access:public	signature:()
SymbolTable::exitscope	symtab.h	/^	void exitscope()$/;"	f	class:SymbolTable	typeref:typename:void	access:public	signature:()
SymbolTable::fatal_error	symtab.h	/^	void fatal_error(char * msg)$/;"	f	class:SymbolTable	typeref:typename:void	access:public	signature:(char * msg)
SymbolTable::lookup	symtab.h	/^	DAT * lookup(SYM s)$/;"	f	class:SymbolTable	typeref:typename:DAT *	access:public	signature:(SYM s)
SymbolTable::operator =	symtab.h	/^	SymbolTable &operator =(const SymbolTable &s) { tbl = s.tbl; return *this; }$/;"	f	class:SymbolTable	typeref:typename:SymbolTable &	access:public	signature:(const SymbolTable & s)
SymbolTable::probe	symtab.h	/^	DAT *probe(SYM s)$/;"	f	class:SymbolTable	typeref:typename:DAT *	access:public	signature:(SYM s)
SymbolTable::tbl	symtab.h	/^	ScopeList  *tbl;$/;"	m	class:SymbolTable	typeref:typename:ScopeList *	access:private
SymtabEntry	symtab.h	/^		SymtabEntry(SYM x, DAT *y) : id(x), info(y) { }$/;"	f	class:SymtabEntry	access:public	signature:(SYM x,DAT * y)
SymtabEntry	symtab.h	/^class SymtabEntry {$/;"	c
SymtabEntry::SymtabEntry	symtab.h	/^		SymtabEntry(SYM x, DAT *y) : id(x), info(y) { }$/;"	f	class:SymtabEntry	access:public	signature:(SYM x,DAT * y)
SymtabEntry::get_id	symtab.h	/^		SYM get_id() const    { return id; }$/;"	f	class:SymtabEntry	typeref:typename:SYM	access:public	signature:() const
SymtabEntry::get_info	symtab.h	/^		DAT *get_info() const { return info; }$/;"	f	class:SymtabEntry	typeref:typename:DAT *	access:public	signature:() const
SymtabEntry::id	symtab.h	/^		SYM id;        \/\/ the key field$/;"	m	class:SymtabEntry	typeref:typename:SYM	access:private
SymtabEntry::info	symtab.h	/^		DAT *info;     \/\/ associated information for the symbol$/;"	m	class:SymtabEntry	typeref:typename:DAT *	access:private
T1	emit.h	/^#define T1 /;"	d
T2	emit.h	/^#define T2 /;"	d
T3	emit.h	/^#define T3 /;"	d
TAG_OFFSET	emit.h	/^#define TAG_OFFSET /;"	d
THEN	cool-parse.h	/^     THEN = 267,$/;"	e	enum:yytokentype	access:public
THEN	cool-parse.h	/^#define THEN /;"	d
TREE_H	tree.h	/^#define TREE_H$/;"	d
TRUE	cgen.h	/^#define TRUE /;"	d
TSRC	Makefile	/^TSRC= mycoolc$/;"	m
TYPCASE	ast-parse.cc	/^     TYPCASE = 269,$/;"	e	enum:yytokentype	file:	access:public
TYPCASE	ast-parse.cc	/^#define TYPCASE /;"	d	file:
TYPCASE	ast-parse.h	/^     TYPCASE = 269,$/;"	e	enum:yytokentype	access:public
TYPCASE	ast-parse.h	/^#define TYPCASE /;"	d
TYPEID	cool-parse.h	/^     TYPEID = 278,$/;"	e	enum:yytokentype	access:public
TYPEID	cool-parse.h	/^#define TYPEID /;"	d
UINT16_MAX	ast-lex.cc	/^#define UINT16_MAX /;"	d	file:
UINT32_MAX	ast-lex.cc	/^#define UINT32_MAX /;"	d	file:
UINT8_MAX	ast-lex.cc	/^#define UINT8_MAX /;"	d	file:
WHILE	cool-parse.h	/^     WHILE = 268,$/;"	e	enum:yytokentype	access:public
WHILE	cool-parse.h	/^#define WHILE /;"	d
WORD	emit.h	/^#define WORD /;"	d
WORD_SIZE	emit.h	/^#define WORD_SIZE /;"	d
YYABORT	ast-parse.cc	/^#define YYABORT	/;"	d	file:
YYACCEPT	ast-parse.cc	/^#define YYACCEPT	/;"	d	file:
YYBACKUP	ast-parse.cc	/^#define YYBACKUP(/;"	d	file:	signature:(Token,Value)
YYBISON	ast-parse.cc	/^#define YYBISON /;"	d	file:
YYBISON_VERSION	ast-parse.cc	/^#define YYBISON_VERSION /;"	d	file:
YYCOPY	ast-parse.cc	/^#   define YYCOPY(/;"	d	file:	signature:(To,From,Count)
YYDEBUG	ast-parse.cc	/^# define YYDEBUG /;"	d	file:
YYDPRINTF	ast-parse.cc	/^# define YYDPRINTF(/;"	d	file:	signature:(Args)
YYEMPTY	ast-parse.cc	/^#define YYEMPTY	/;"	d	file:
YYEOF	ast-parse.cc	/^#define YYEOF	/;"	d	file:
YYERRCODE	ast-parse.cc	/^#define YYERRCODE	/;"	d	file:
YYERROR	ast-parse.cc	/^#define YYERROR	/;"	d	file:
YYERROR_VERBOSE	ast-parse.cc	/^# define YYERROR_VERBOSE /;"	d	file:
YYERROR_VERBOSE_ARGS_MAXIMUM	ast-parse.cc	/^      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };$/;"	e	enum:yysyntax_error::__anonb60ba6e90103	file:	access:public
YYFAIL	ast-parse.cc	/^#define YYFAIL	/;"	d	file:
YYFINAL	ast-parse.cc	/^#define YYFINAL /;"	d	file:
YYFPRINTF	ast-parse.cc	/^#  define YYFPRINTF /;"	d	file:
YYFREE	ast-parse.cc	/^#   define YYFREE /;"	d	file:
YYID	ast-parse.cc	/^# define YYID(/;"	d	file:	signature:(n)
YYID	ast-parse.cc	/^YYID (int i)$/;"	f	typeref:typename:int	file:	signature:(int i)
YYINITDEPTH	ast-parse.cc	/^# define YYINITDEPTH /;"	d	file:
YYLAST	ast-parse.cc	/^#define YYLAST /;"	d	file:
YYLEX	ast-parse.cc	/^# define YYLEX /;"	d	file:
YYLLOC_DEFAULT	ast-parse.cc	/^# define YYLLOC_DEFAULT(/;"	d	file:	signature:(Current,Rhs,N)
YYLSP_NEEDED	ast-parse.cc	/^#define YYLSP_NEEDED /;"	d	file:
YYLTYPE	cool-parse.h	/^typedef struct YYLTYPE$/;"	s
YYLTYPE	cool-parse.h	/^} YYLTYPE;$/;"	t	typeref:struct:YYLTYPE
YYLTYPE::first_column	cool-parse.h	/^  int first_column;$/;"	m	struct:YYLTYPE	typeref:typename:int	access:public
YYLTYPE::first_line	cool-parse.h	/^  int first_line;$/;"	m	struct:YYLTYPE	typeref:typename:int	access:public
YYLTYPE::last_column	cool-parse.h	/^  int last_column;$/;"	m	struct:YYLTYPE	typeref:typename:int	access:public
YYLTYPE::last_line	cool-parse.h	/^  int last_line;$/;"	m	struct:YYLTYPE	typeref:typename:int	access:public
YYLTYPE_IS_DECLARED	cool-parse.h	/^# define YYLTYPE_IS_DECLARED /;"	d
YYLTYPE_IS_TRIVIAL	cool-parse.h	/^# define YYLTYPE_IS_TRIVIAL /;"	d
YYMALLOC	ast-parse.cc	/^#   define YYMALLOC /;"	d	file:
YYMAXDEPTH	ast-parse.cc	/^# define YYMAXDEPTH /;"	d	file:
YYMAXUTOK	ast-parse.cc	/^#define YYMAXUTOK /;"	d	file:
YYNNTS	ast-parse.cc	/^#define YYNNTS /;"	d	file:
YYNRULES	ast-parse.cc	/^#define YYNRULES /;"	d	file:
YYNSTATES	ast-parse.cc	/^#define YYNSTATES /;"	d	file:
YYNTOKENS	ast-parse.cc	/^#define YYNTOKENS /;"	d	file:
YYPACT_NINF	ast-parse.cc	/^#define YYPACT_NINF /;"	d	file:
YYPOPSTACK	ast-parse.cc	/^#define YYPOPSTACK(/;"	d	file:	signature:(N)
YYPURE	ast-parse.cc	/^#define YYPURE /;"	d	file:
YYRECOVERING	ast-parse.cc	/^#define YYRECOVERING(/;"	d	file:	signature:()
YYRHSLOC	ast-parse.cc	/^#define YYRHSLOC(/;"	d	file:	signature:(Rhs,K)
YYSIZE_MAXIMUM	ast-parse.cc	/^#define YYSIZE_MAXIMUM /;"	d	file:
YYSIZE_T	ast-parse.cc	/^#  define YYSIZE_T /;"	d	file:
YYSKELETON_NAME	ast-parse.cc	/^#define YYSKELETON_NAME /;"	d	file:
YYSTACK_ALLOC	ast-parse.cc	/^#    define YYSTACK_ALLOC /;"	d	file:
YYSTACK_ALLOC	ast-parse.cc	/^#  define YYSTACK_ALLOC /;"	d	file:
YYSTACK_ALLOC_MAXIMUM	ast-parse.cc	/^#   define YYSTACK_ALLOC_MAXIMUM /;"	d	file:
YYSTACK_BYTES	ast-parse.cc	/^# define YYSTACK_BYTES(/;"	d	file:	signature:(N)
YYSTACK_FREE	ast-parse.cc	/^#  define YYSTACK_FREE /;"	d	file:
YYSTACK_FREE	ast-parse.cc	/^#  define YYSTACK_FREE(/;"	d	file:	signature:(Ptr)
YYSTACK_GAP_MAXIMUM	ast-parse.cc	/^# define YYSTACK_GAP_MAXIMUM /;"	d	file:
YYSTACK_RELOCATE	ast-parse.cc	/^# define YYSTACK_RELOCATE(/;"	d	file:	signature:(Stack)
YYSTATE	ast-lex.cc	/^#define YYSTATE /;"	d	file:
YYSTYPE	ast-parse.cc	/^	YYSTYPE;$/;"	t	typeref:union:YYSTYPE	file:
YYSTYPE	ast-parse.cc	/^typedef union YYSTYPE$/;"	u	file:
YYSTYPE	ast-parse.h	/^	YYSTYPE;$/;"	t	typeref:union:YYSTYPE
YYSTYPE	ast-parse.h	/^typedef union YYSTYPE$/;"	u
YYSTYPE	cool-parse.h	/^	YYSTYPE;$/;"	t	typeref:union:YYSTYPE
YYSTYPE	cool-parse.h	/^typedef union YYSTYPE$/;"	u
YYSTYPE::boolean	ast-parse.cc	/^  Boolean boolean;$/;"	m	union:YYSTYPE	typeref:typename:Boolean	file:	access:public
YYSTYPE::boolean	ast-parse.h	/^  Boolean boolean;$/;"	m	union:YYSTYPE	typeref:typename:Boolean	access:public
YYSTYPE::boolean	cool-parse.h	/^  Boolean boolean;$/;"	m	union:YYSTYPE	typeref:typename:Boolean	access:public
YYSTYPE::case_	ast-parse.cc	/^  Case case_;$/;"	m	union:YYSTYPE	typeref:typename:Case	file:	access:public
YYSTYPE::case_	ast-parse.h	/^  Case case_;$/;"	m	union:YYSTYPE	typeref:typename:Case	access:public
YYSTYPE::case_	cool-parse.h	/^  Case case_;$/;"	m	union:YYSTYPE	typeref:typename:Case	access:public
YYSTYPE::cases	ast-parse.cc	/^  Cases cases;$/;"	m	union:YYSTYPE	typeref:typename:Cases	file:	access:public
YYSTYPE::cases	ast-parse.h	/^  Cases cases;$/;"	m	union:YYSTYPE	typeref:typename:Cases	access:public
YYSTYPE::cases	cool-parse.h	/^  Cases cases;$/;"	m	union:YYSTYPE	typeref:typename:Cases	access:public
YYSTYPE::class_	ast-parse.cc	/^  Class_ class_;$/;"	m	union:YYSTYPE	typeref:typename:Class_	file:	access:public
YYSTYPE::class_	ast-parse.h	/^  Class_ class_;$/;"	m	union:YYSTYPE	typeref:typename:Class_	access:public
YYSTYPE::class_	cool-parse.h	/^  Class_ class_;$/;"	m	union:YYSTYPE	typeref:typename:Class_	access:public
YYSTYPE::classes	ast-parse.cc	/^  Classes classes;$/;"	m	union:YYSTYPE	typeref:typename:Classes	file:	access:public
YYSTYPE::classes	ast-parse.h	/^  Classes classes;$/;"	m	union:YYSTYPE	typeref:typename:Classes	access:public
YYSTYPE::classes	cool-parse.h	/^  Classes classes;$/;"	m	union:YYSTYPE	typeref:typename:Classes	access:public
YYSTYPE::error_msg	cool-parse.h	/^  char *error_msg;$/;"	m	union:YYSTYPE	typeref:typename:char *	access:public
YYSTYPE::expression	ast-parse.cc	/^  Expression expression;$/;"	m	union:YYSTYPE	typeref:typename:Expression	file:	access:public
YYSTYPE::expression	ast-parse.h	/^  Expression expression;$/;"	m	union:YYSTYPE	typeref:typename:Expression	access:public
YYSTYPE::expression	cool-parse.h	/^  Expression expression;$/;"	m	union:YYSTYPE	typeref:typename:Expression	access:public
YYSTYPE::expressions	ast-parse.cc	/^  Expressions expressions;$/;"	m	union:YYSTYPE	typeref:typename:Expressions	file:	access:public
YYSTYPE::expressions	ast-parse.h	/^  Expressions expressions;$/;"	m	union:YYSTYPE	typeref:typename:Expressions	access:public
YYSTYPE::expressions	cool-parse.h	/^  Expressions expressions;$/;"	m	union:YYSTYPE	typeref:typename:Expressions	access:public
YYSTYPE::feature	ast-parse.cc	/^  Feature feature;$/;"	m	union:YYSTYPE	typeref:typename:Feature	file:	access:public
YYSTYPE::feature	ast-parse.h	/^  Feature feature;$/;"	m	union:YYSTYPE	typeref:typename:Feature	access:public
YYSTYPE::feature	cool-parse.h	/^  Feature feature;$/;"	m	union:YYSTYPE	typeref:typename:Feature	access:public
YYSTYPE::features	ast-parse.cc	/^  Features features;$/;"	m	union:YYSTYPE	typeref:typename:Features	file:	access:public
YYSTYPE::features	ast-parse.h	/^  Features features;$/;"	m	union:YYSTYPE	typeref:typename:Features	access:public
YYSTYPE::features	cool-parse.h	/^  Features features;$/;"	m	union:YYSTYPE	typeref:typename:Features	access:public
YYSTYPE::formal	ast-parse.cc	/^  Formal formal;$/;"	m	union:YYSTYPE	typeref:typename:Formal	file:	access:public
YYSTYPE::formal	ast-parse.h	/^  Formal formal;$/;"	m	union:YYSTYPE	typeref:typename:Formal	access:public
YYSTYPE::formal	cool-parse.h	/^  Formal formal;$/;"	m	union:YYSTYPE	typeref:typename:Formal	access:public
YYSTYPE::formals	ast-parse.cc	/^  Formals formals;$/;"	m	union:YYSTYPE	typeref:typename:Formals	file:	access:public
YYSTYPE::formals	ast-parse.h	/^  Formals formals;$/;"	m	union:YYSTYPE	typeref:typename:Formals	access:public
YYSTYPE::formals	cool-parse.h	/^  Formals formals;$/;"	m	union:YYSTYPE	typeref:typename:Formals	access:public
YYSTYPE::lineno	ast-parse.cc	/^  int lineno;$/;"	m	union:YYSTYPE	typeref:typename:int	file:	access:public
YYSTYPE::lineno	ast-parse.h	/^  int lineno;$/;"	m	union:YYSTYPE	typeref:typename:int	access:public
YYSTYPE::program	ast-parse.cc	/^  Program program;$/;"	m	union:YYSTYPE	typeref:typename:Program	file:	access:public
YYSTYPE::program	ast-parse.h	/^  Program program;$/;"	m	union:YYSTYPE	typeref:typename:Program	access:public
YYSTYPE::program	cool-parse.h	/^  Program program;$/;"	m	union:YYSTYPE	typeref:typename:Program	access:public
YYSTYPE::symbol	ast-parse.cc	/^  Symbol symbol;$/;"	m	union:YYSTYPE	typeref:typename:Symbol	file:	access:public
YYSTYPE::symbol	ast-parse.h	/^  Symbol symbol;$/;"	m	union:YYSTYPE	typeref:typename:Symbol	access:public
YYSTYPE::symbol	cool-parse.h	/^  Symbol symbol;$/;"	m	union:YYSTYPE	typeref:typename:Symbol	access:public
YYSTYPE_IS_DECLARED	ast-parse.cc	/^# define YYSTYPE_IS_DECLARED /;"	d	file:
YYSTYPE_IS_DECLARED	ast-parse.h	/^# define YYSTYPE_IS_DECLARED /;"	d
YYSTYPE_IS_DECLARED	cool-parse.h	/^# define YYSTYPE_IS_DECLARED /;"	d
YYSTYPE_IS_TRIVIAL	ast-parse.cc	/^# define YYSTYPE_IS_TRIVIAL /;"	d	file:
YYSTYPE_IS_TRIVIAL	ast-parse.h	/^# define YYSTYPE_IS_TRIVIAL /;"	d
YYSTYPE_IS_TRIVIAL	cool-parse.h	/^# define YYSTYPE_IS_TRIVIAL /;"	d
YYTABLES_NAME	ast-lex.cc	/^#define YYTABLES_NAME /;"	d	file:
YYTABLE_NINF	ast-parse.cc	/^#define YYTABLE_NINF /;"	d	file:
YYTERROR	ast-parse.cc	/^#define YYTERROR	/;"	d	file:
YYTOKENTYPE	ast-parse.cc	/^# define YYTOKENTYPE$/;"	d	file:
YYTOKENTYPE	ast-parse.h	/^# define YYTOKENTYPE$/;"	d
YYTOKENTYPE	cool-parse.h	/^# define YYTOKENTYPE$/;"	d
YYTOKEN_TABLE	ast-parse.cc	/^# define YYTOKEN_TABLE /;"	d	file:
YYTRANSLATE	ast-parse.cc	/^#define YYTRANSLATE(/;"	d	file:	signature:(YYX)
YYUNDEFTOK	ast-parse.cc	/^#define YYUNDEFTOK /;"	d	file:
YYUSE	ast-parse.cc	/^# define YYUSE(/;"	d	file:	signature:(e)
YY_	ast-parse.cc	/^#   define YY_(/;"	d	file:	signature:(msgid)
YY_	ast-parse.cc	/^#  define YY_(/;"	d	file:	signature:(msgid)
YY_AT_BOL	ast-lex.cc	/^#define YY_AT_BOL(/;"	d	file:	signature:()
YY_BREAK	ast-lex.cc	/^#define YY_BREAK /;"	d	file:
YY_BUFFER_EOF_PENDING	ast-lex.cc	/^#define YY_BUFFER_EOF_PENDING /;"	d	file:
YY_BUFFER_NEW	ast-lex.cc	/^#define YY_BUFFER_NEW /;"	d	file:
YY_BUFFER_NORMAL	ast-lex.cc	/^#define YY_BUFFER_NORMAL /;"	d	file:
YY_BUFFER_STATE	ast-lex.cc	/^typedef struct yy_buffer_state *YY_BUFFER_STATE;$/;"	t	typeref:struct:yy_buffer_state *	file:
YY_BUF_SIZE	ast-lex.cc	/^#define YY_BUF_SIZE /;"	d	file:
YY_CHAR	ast-lex.cc	/^typedef unsigned char YY_CHAR;$/;"	t	typeref:typename:unsigned char	file:
YY_CURRENT_BUFFER	ast-lex.cc	/^#define YY_CURRENT_BUFFER /;"	d	file:
YY_CURRENT_BUFFER_LVALUE	ast-lex.cc	/^#define YY_CURRENT_BUFFER_LVALUE /;"	d	file:
YY_DECL	ast-lex.cc	/^#define YY_DECL /;"	d	file:
YY_DECL_IS_OURS	ast-lex.cc	/^#define YY_DECL_IS_OURS /;"	d	file:
YY_DO_BEFORE_ACTION	ast-lex.cc	/^#define YY_DO_BEFORE_ACTION /;"	d	file:
YY_END_OF_BUFFER	ast-lex.cc	/^#define YY_END_OF_BUFFER /;"	d	file:
YY_END_OF_BUFFER_CHAR	ast-lex.cc	/^#define YY_END_OF_BUFFER_CHAR /;"	d	file:
YY_EXIT_FAILURE	ast-lex.cc	/^#define YY_EXIT_FAILURE /;"	d	file:
YY_EXTRA_TYPE	ast-lex.cc	/^#define YY_EXTRA_TYPE /;"	d	file:
YY_FATAL_ERROR	ast-lex.cc	/^#define YY_FATAL_ERROR(/;"	d	file:	signature:(msg)
YY_FLEX_MAJOR_VERSION	ast-lex.cc	/^#define YY_FLEX_MAJOR_VERSION /;"	d	file:
YY_FLEX_MINOR_VERSION	ast-lex.cc	/^#define YY_FLEX_MINOR_VERSION /;"	d	file:
YY_FLEX_SUBMINOR_VERSION	ast-lex.cc	/^#define YY_FLEX_SUBMINOR_VERSION /;"	d	file:
YY_FLUSH_BUFFER	ast-lex.cc	/^#define YY_FLUSH_BUFFER /;"	d	file:
YY_INPUT	ast-lex.cc	/^#define YY_INPUT(/;"	d	file:	signature:(buf,result,max_size)
YY_INT_ALIGNED	ast-lex.cc	/^#define  YY_INT_ALIGNED /;"	d	file:
YY_LESS_LINENO	ast-lex.cc	/^    #define YY_LESS_LINENO(/;"	d	file:	signature:(n)
YY_LOCATION_PRINT	ast-parse.cc	/^#  define YY_LOCATION_PRINT(/;"	d	file:	signature:(File,Loc)
YY_MORE_ADJ	ast-lex.cc	/^#define YY_MORE_ADJ /;"	d	file:
YY_NEW_FILE	ast-lex.cc	/^#define YY_NEW_FILE /;"	d	file:
YY_NO_UNPUT	ast-lex.cc	/^#define YY_NO_UNPUT /;"	d	file:
YY_NULL	ast-lex.cc	/^#define YY_NULL /;"	d	file:
YY_NUM_RULES	ast-lex.cc	/^#define YY_NUM_RULES /;"	d	file:
YY_READ_BUF_SIZE	ast-lex.cc	/^#define YY_READ_BUF_SIZE /;"	d	file:
YY_REDUCE_PRINT	ast-parse.cc	/^# define YY_REDUCE_PRINT(/;"	d	file:	signature:(Rule)
YY_RESTORE_YY_MORE_OFFSET	ast-lex.cc	/^#define YY_RESTORE_YY_MORE_OFFSET$/;"	d	file:
YY_RULE_SETUP	ast-lex.cc	/^#define YY_RULE_SETUP /;"	d	file:
YY_SC_TO_UI	ast-lex.cc	/^#define YY_SC_TO_UI(/;"	d	file:	signature:(c)
YY_STACK_PRINT	ast-parse.cc	/^# define YY_STACK_PRINT(/;"	d	file:	signature:(Bottom,Top)
YY_START	ast-lex.cc	/^#define YY_START /;"	d	file:
YY_START_STACK_INCR	ast-lex.cc	/^#define YY_START_STACK_INCR /;"	d	file:
YY_STATE_BUF_SIZE	ast-lex.cc	/^#define YY_STATE_BUF_SIZE /;"	d	file:
YY_STATE_EOF	ast-lex.cc	/^#define YY_STATE_EOF(/;"	d	file:	signature:(state)
YY_STRUCT_YY_BUFFER_STATE	ast-lex.cc	/^#define YY_STRUCT_YY_BUFFER_STATE$/;"	d	file:
YY_SYMBOL_PRINT	ast-parse.cc	/^# define YY_SYMBOL_PRINT(/;"	d	file:	signature:(Title,Type,Value,Location)
YY_TYPEDEF_YY_BUFFER_STATE	ast-lex.cc	/^#define YY_TYPEDEF_YY_BUFFER_STATE$/;"	d	file:
YY_TYPEDEF_YY_SIZE_T	ast-lex.cc	/^#define YY_TYPEDEF_YY_SIZE_T$/;"	d	file:
YY_USER_ACTION	ast-lex.cc	/^#define YY_USER_ACTION$/;"	d	file:
YY_USE_CONST	ast-lex.cc	/^#define YY_USE_CONST$/;"	d	file:
ZERO	emit.h	/^#define ZERO /;"	d
_AST_PARSE_H	ast-parse.h	/^#define _AST_PARSE_H$/;"	d
_COOL_H_	ast-parse.h	/^#define _COOL_H_$/;"	d
_COOL_H_	cool-parse.h	/^#define _COOL_H_$/;"	d
_COOL_H_	cool.h	/^#define _COOL_H_$/;"	d
_COOL_PARSE_H	cool-parse.h	/^#define _COOL_PARSE_H$/;"	d
_LIST_H_	list.h	/^#define _LIST_H_$/;"	d
_STDLIB_H	ast-parse.cc	/^#      define _STDLIB_H /;"	d	file:
_STDLIB_H	ast-parse.cc	/^#    define _STDLIB_H /;"	d	file:
_STRINGTAB_H_	stringtab.h	/^#define _STRINGTAB_H_$/;"	d
_SYMTAB_H_	symtab.h	/^#define _SYMTAB_H_$/;"	d
_UTILITIES_H_	utilities.h	/^#define _UTILITIES_H_$/;"	d
__STDC_LIMIT_MACROS	ast-lex.cc	/^#define __STDC_LIMIT_MACROS /;"	d	file:
__anonb60ba6e90103	ast-parse.cc	/^      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };$/;"	g	function:yysyntax_error	file:
actual	cool-tree.h	/^   Expressions actual;$/;"	m	class:dispatch_class	typeref:typename:Expressions	access:protected
actual	cool-tree.h	/^   Expressions actual;$/;"	m	class:static_dispatch_class	typeref:typename:Expressions	access:protected
add_Argument	cgen.h	/^		void add_Argument(Symbol s) {$/;"	f	class:Environment	typeref:typename:void	access:public	signature:(Symbol s)
add_Attribute	cgen.h	/^		void add_Attribute(CgenNodeP p) { attr_index = p->attr_index; }$/;"	f	class:Environment	typeref:typename:void	access:public	signature:(CgenNodeP p)
add_Variable	cgen.h	/^		void add_Variable(Symbol s, int id) { var_index.addid(s, new int(id)); }$/;"	f	class:Environment	typeref:typename:void	access:public	signature:(Symbol s,int id)
add_child	cgen.cc	/^void CgenNode::add_child(CgenNodeP n)$/;"	f	class:CgenNode	typeref:typename:void	signature:(CgenNodeP n)
add_child	cgen.h	/^		void add_child(CgenNodeP child);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(CgenNodeP child)
add_int	stringtab.h	/^		Elem *add_int(int i);$/;"	p	class:StringTable	typeref:typename:Elem *	access:public	signature:(int i)
add_int	stringtab_functions.h	/^Elem *StringTable<Elem>::add_int(int i)$/;"	f	class:StringTable	typeref:typename:Elem *	signature:(int i)
add_string	stringtab.h	/^		Elem *add_string(char *s);$/;"	p	class:StringTable	typeref:typename:Elem *	access:public	signature:(char * s)
add_string	stringtab.h	/^		Elem *add_string(char *s, int maxchars);$/;"	p	class:StringTable	typeref:typename:Elem *	access:public	signature:(char * s,int maxchars)
add_string	stringtab_functions.h	/^Elem *StringTable<Elem>::add_string(char *s)$/;"	f	class:StringTable	typeref:typename:Elem *	signature:(char * s)
add_string	stringtab_functions.h	/^Elem *StringTable<Elem>::add_string(char *s, int maxchars)$/;"	f	class:StringTable	typeref:typename:Elem *	signature:(char * s,int maxchars)
addid	symtab.h	/^	ScopeEntry *addid(SYM s, DAT *i)$/;"	f	class:SymbolTable	typeref:typename:ScopeEntry *	access:public	signature:(SYM s,DAT * i)
alloca	ast-parse.cc	/^#    define alloca /;"	d	file:
append	tree.h	/^    static list_node<Elem> *append(list_node<Elem> *l1,list_node<Elem> *l2);$/;"	p	class:list_node	typeref:typename:list_node<Elem> *	access:public	signature:(list_node<Elem> * l1,list_node<Elem> * l2)
append	tree.h	/^template <class Elem> list_node<Elem> *list_node<Elem>::append(list_node<Elem> *l1,list_node<Ele/;"	f	class:list_node	typeref:typename:list_node<Elem> *	signature:(list_node<Elem> * l1,list_node<Elem> * l2)
append_Cases	cool-tree.cc	/^Cases append_Cases(Cases p1, Cases p2)$/;"	f	typeref:typename:Cases	signature:(Cases p1,Cases p2)
append_Cases	cool-tree.h	/^Cases append_Cases(Cases, Cases);$/;"	p	typeref:typename:Cases	signature:(Cases,Cases)
append_Classes	cool-tree.cc	/^Classes append_Classes(Classes p1, Classes p2)$/;"	f	typeref:typename:Classes	signature:(Classes p1,Classes p2)
append_Classes	cool-tree.h	/^Classes append_Classes(Classes, Classes);$/;"	p	typeref:typename:Classes	signature:(Classes,Classes)
append_Expressions	cool-tree.cc	/^Expressions append_Expressions(Expressions p1, Expressions p2)$/;"	f	typeref:typename:Expressions	signature:(Expressions p1,Expressions p2)
append_Expressions	cool-tree.h	/^Expressions append_Expressions(Expressions, Expressions);$/;"	p	typeref:typename:Expressions	signature:(Expressions,Expressions)
append_Features	cool-tree.cc	/^Features append_Features(Features p1, Features p2)$/;"	f	typeref:typename:Features	signature:(Features p1,Features p2)
append_Features	cool-tree.h	/^Features append_Features(Features, Features);$/;"	p	typeref:typename:Features	signature:(Features,Features)
append_Formals	cool-tree.cc	/^Formals append_Formals(Formals p1, Formals p2)$/;"	f	typeref:typename:Formals	signature:(Formals p1,Formals p2)
append_Formals	cool-tree.h	/^Formals append_Formals(Formals, Formals);$/;"	p	typeref:typename:Formals	signature:(Formals,Formals)
append_node	tree.h	/^    append_node(list_node<Elem> *l1, list_node<Elem> *l2) {$/;"	f	class:append_node	access:public	signature:(list_node<Elem> * l1,list_node<Elem> * l2)
append_node	tree.h	/^template <class Elem> class append_node : public list_node<Elem> {$/;"	c	inherits:list_node<Elem>
append_node::append_node	tree.h	/^    append_node(list_node<Elem> *l1, list_node<Elem> *l2) {$/;"	f	class:append_node	access:public	signature:(list_node<Elem> * l1,list_node<Elem> * l2)
append_node::copy_list	tree.h	/^    list_node<Elem> *copy_list();$/;"	p	class:append_node	typeref:typename:list_node<Elem> *	access:public	signature:()
append_node::copy_list	tree.h	/^template <class Elem> list_node<Elem> *append_node<Elem>::copy_list()$/;"	f	class:append_node	typeref:typename:list_node<Elem> *	signature:()
append_node::dump	tree.h	/^    void dump(ostream& stream, int n);$/;"	p	class:append_node	typeref:typename:void	access:public	signature:(ostream & stream,int n)
append_node::dump	tree.h	/^template <class Elem> void append_node<Elem>::dump(ostream& stream, int n)$/;"	f	class:append_node	typeref:typename:void	signature:(ostream & stream,int n)
append_node::len	tree.h	/^    int len();$/;"	p	class:append_node	typeref:typename:int	access:public	signature:()
append_node::len	tree.h	/^template <class Elem> int append_node<Elem>::len()$/;"	f	class:append_node	typeref:typename:int	signature:()
append_node::nth	tree.h	/^    Elem nth(int n);$/;"	p	class:append_node	typeref:typename:Elem	access:public	signature:(int n)
append_node::nth	tree.h	/^template <class Elem> Elem append_node<Elem>::nth(int n)$/;"	f	class:append_node	typeref:typename:Elem	signature:(int n)
append_node::nth_length	tree.h	/^    Elem nth_length(int n, int &len);$/;"	p	class:append_node	typeref:typename:Elem	access:public	signature:(int n,int & len)
append_node::nth_length	tree.h	/^template <class Elem> Elem append_node<Elem>::nth_length(int n, int &len)$/;"	f	class:append_node	typeref:typename:Elem	signature:(int n,int & len)
append_node::rest	tree.h	/^    list_node<Elem> *some, *rest;$/;"	m	class:append_node	typeref:typename:list_node<Elem> *	access:private
append_node::some	tree.h	/^    list_node<Elem> *some, *rest;$/;"	m	class:append_node	typeref:typename:list_node<Elem> *	access:private
arg	cgen.cc	/^arg,$/;"	v	typeref:typename:Symbol
arg2	cgen.cc	/^	arg2,$/;"	v	typeref:typename:Symbol
args_enter	cgen.h	/^		void args_enter() { args_index.enterscope(); }$/;"	f	class:Environment	typeref:typename:void	access:public	signature:()
args_exit	cgen.h	/^		void args_exit() { args_index.exitscope(); }$/;"	f	class:Environment	typeref:typename:void	access:public	signature:()
args_index	cgen.h	/^		SymbolTable<Symbol, int> args_index;$/;"	m	class:Environment	typeref:typename:SymbolTable<Symbol,int>	access:public
args_size	cgen.h	/^		int args_size = 0, var_scopes = 0;$/;"	m	class:Environment	typeref:typename:int	access:public
ascii	cgen_supp.cc	/^static int ascii = 0;$/;"	v	typeref:typename:int	file:
ascii_mode	cgen_supp.cc	/^void ascii_mode(ostream& str)$/;"	f	typeref:typename:void	signature:(ostream & str)
assert_Boolean	ast-parse.h	/^void assert_Boolean(Boolean);$/;"	p	typeref:typename:void	signature:(Boolean)
assert_Boolean	cool-parse.h	/^void assert_Boolean(Boolean);$/;"	p	typeref:typename:void	signature:(Boolean)
assert_Boolean	cool-tree.handcode.h	/^inline void assert_Boolean(Boolean) {}$/;"	f	typeref:typename:void	signature:(Boolean)
assert_Boolean	cool.h	/^void assert_Boolean(Boolean);$/;"	p	typeref:typename:void	signature:(Boolean)
assert_Symbol	ast-parse.h	/^void assert_Symbol(Symbol);$/;"	p	typeref:typename:void	signature:(Symbol)
assert_Symbol	cool-parse.h	/^void assert_Symbol(Symbol);$/;"	p	typeref:typename:void	signature:(Symbol)
assert_Symbol	cool-tree.handcode.h	/^void assert_Symbol(Symbol b);$/;"	p	typeref:typename:void	signature:(Symbol b)
assert_Symbol	cool.h	/^void assert_Symbol(Symbol);$/;"	p	typeref:typename:void	signature:(Symbol)
assign	cool-tree.cc	/^Expression assign(Symbol name, Expression expr)$/;"	f	typeref:typename:Expression	signature:(Symbol name,Expression expr)
assign	cool-tree.h	/^Expression assign(Symbol, Expression);$/;"	p	typeref:typename:Expression	signature:(Symbol,Expression)
assign_class	cool-tree.h	/^   assign_class(Symbol a1, Expression a2) {$/;"	f	class:assign_class	access:public	signature:(Symbol a1,Expression a2)
assign_class	cool-tree.h	/^class assign_class : public Expression_class {$/;"	c	inherits:Expression_class
assign_class::assign_class	cool-tree.h	/^   assign_class(Symbol a1, Expression a2) {$/;"	f	class:assign_class	access:public	signature:(Symbol a1,Expression a2)
assign_class::code	cgen.cc	/^void assign_class::code(ostream &s) {$/;"	f	class:assign_class	typeref:typename:void	signature:(ostream & s)
assign_class::copy_Expression	cool-tree.cc	/^Expression assign_class::copy_Expression()$/;"	f	class:assign_class	typeref:typename:Expression	signature:()
assign_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:assign_class	typeref:typename:Expression	access:public	signature:()
assign_class::dump	cool-tree.cc	/^void assign_class::dump(ostream& stream, int n)$/;"	f	class:assign_class	typeref:typename:void	signature:(ostream & stream,int n)
assign_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:assign_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
assign_class::dump_with_types	dumptype.cc	/^void assign_class::dump_with_types(ostream& stream, int n)$/;"	f	class:assign_class	typeref:typename:void	signature:(ostream & stream,int n)
assign_class::expr	cool-tree.h	/^   Expression expr;$/;"	m	class:assign_class	typeref:typename:Expression	access:protected
assign_class::name	cool-tree.h	/^   Symbol name;$/;"	m	class:assign_class	typeref:typename:Symbol	access:protected
assign_class::tmp_Num	cgen.cc	/^int assign_class::tmp_Num() { return expr->tmp_Num(); }$/;"	f	class:assign_class	typeref:typename:int	signature:()
ast_file	cgen-phase.cc	/^FILE *ast_file = stdin;       \/\/ we read the AST from standard input$/;"	v	typeref:typename:FILE *
ast_root	ast-parse.cc	/^Program ast_root;             \/* the result of the parse  *\/$/;"	v	typeref:typename:Program
ast_yyerror	ast-parse.cc	/^void ast_yyerror(char *);$/;"	p	typeref:typename:void	file:	signature:(char *)
ast_yyerror	ast-parse.cc	/^void ast_yyerror(char *msg)$/;"	f	typeref:typename:void	signature:(char * msg)
ast_yyparse	cgen-phase.cc	/^extern int ast_yyparse(void); \/\/ entry point to the AST parser$/;"	p	typeref:typename:int	file:	signature:(void)
attr	cool-tree.cc	/^Feature attr(Symbol name, Symbol type_decl, Expression init)$/;"	f	typeref:typename:Feature	signature:(Symbol name,Symbol type_decl,Expression init)
attr	cool-tree.h	/^Feature attr(Symbol, Symbol, Expression);$/;"	p	typeref:typename:Feature	signature:(Symbol,Symbol,Expression)
attr_EXTRAS	cool-tree.handcode.h	/^#define attr_EXTRAS	/;"	d
attr_class	cool-tree.h	/^   attr_class(Symbol a1, Symbol a2, Expression a3) {$/;"	f	class:attr_class	access:public	signature:(Symbol a1,Symbol a2,Expression a3)
attr_class	cool-tree.h	/^class attr_class : public Feature_class {$/;"	c	inherits:Feature_class
attr_class::attr_class	cool-tree.h	/^   attr_class(Symbol a1, Symbol a2, Expression a3) {$/;"	f	class:attr_class	access:public	signature:(Symbol a1,Symbol a2,Expression a3)
attr_class::code	cgen.cc	/^void attr_class::code(ostream &s) {}$/;"	f	class:attr_class	typeref:typename:void	signature:(ostream & s)
attr_class::copy_Feature	cool-tree.cc	/^Feature attr_class::copy_Feature()$/;"	f	class:attr_class	typeref:typename:Feature	signature:()
attr_class::copy_Feature	cool-tree.h	/^   Feature copy_Feature();$/;"	p	class:attr_class	typeref:typename:Feature	access:public	signature:()
attr_class::dump	cool-tree.cc	/^void attr_class::dump(ostream& stream, int n)$/;"	f	class:attr_class	typeref:typename:void	signature:(ostream & stream,int n)
attr_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:attr_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
attr_class::dump_with_types	dumptype.cc	/^void attr_class::dump_with_types(ostream& stream, int n)$/;"	f	class:attr_class	typeref:typename:void	signature:(ostream & stream,int n)
attr_class::init	cool-tree.h	/^   Expression init;$/;"	m	class:attr_class	typeref:typename:Expression	access:protected
attr_class::name	cool-tree.h	/^   Symbol name;$/;"	m	class:attr_class	typeref:typename:Symbol	access:protected
attr_class::tmp_Num	cgen.cc	/^int attr_class::tmp_Num() { return init->tmp_Num(); }$/;"	f	class:attr_class	typeref:typename:int	signature:()
attr_class::type_decl	cool-tree.h	/^   Symbol type_decl;$/;"	m	class:attr_class	typeref:typename:Symbol	access:protected
attr_index	cgen.h	/^		std::map<Symbol, int> attr_index;$/;"	m	class:CgenNode	typeref:typename:std::map<Symbol,int>	access:public
attr_index	cgen.h	/^		std::map<Symbol, int> attr_index;$/;"	m	class:Environment	typeref:typename:std::map<Symbol,int>	access:public
b	ast-lex.cc	/^			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;$/;"	v	typeref:typename:YY_BUFFER_STATE
basic	cgen.h	/^		int basic() { return (basic_status == Basic); }$/;"	f	class:CgenNode	typeref:typename:int	access:public	signature:()
basic_status	cgen.h	/^		Basicness basic_status;                    \/\/ `Basic' if class is basic$/;"	m	class:CgenNode	typeref:typename:Basicness	access:private
block	cool-tree.cc	/^Expression block(Expressions body)$/;"	f	typeref:typename:Expression	signature:(Expressions body)
block	cool-tree.h	/^Expression block(Expressions);$/;"	p	typeref:typename:Expression	signature:(Expressions)
block_class	cool-tree.h	/^   block_class(Expressions a1) {$/;"	f	class:block_class	access:public	signature:(Expressions a1)
block_class	cool-tree.h	/^class block_class : public Expression_class {$/;"	c	inherits:Expression_class
block_class::block_class	cool-tree.h	/^   block_class(Expressions a1) {$/;"	f	class:block_class	access:public	signature:(Expressions a1)
block_class::body	cool-tree.h	/^   Expressions body;$/;"	m	class:block_class	typeref:typename:Expressions	access:protected
block_class::code	cgen.cc	/^void block_class::code(ostream &s) {$/;"	f	class:block_class	typeref:typename:void	signature:(ostream & s)
block_class::copy_Expression	cool-tree.cc	/^Expression block_class::copy_Expression()$/;"	f	class:block_class	typeref:typename:Expression	signature:()
block_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:block_class	typeref:typename:Expression	access:public	signature:()
block_class::dump	cool-tree.cc	/^void block_class::dump(ostream& stream, int n)$/;"	f	class:block_class	typeref:typename:void	signature:(ostream & stream,int n)
block_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:block_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
block_class::dump_with_types	dumptype.cc	/^void block_class::dump_with_types(ostream& stream, int n)$/;"	f	class:block_class	typeref:typename:void	signature:(ostream & stream,int n)
body	cool-tree.h	/^   Expression body;$/;"	m	class:let_class	typeref:typename:Expression	access:protected
body	cool-tree.h	/^   Expression body;$/;"	m	class:loop_class	typeref:typename:Expression	access:protected
body	cool-tree.h	/^   Expressions body;$/;"	m	class:block_class	typeref:typename:Expressions	access:protected
bool_const	cool-tree.cc	/^Expression bool_const(Boolean val)$/;"	f	typeref:typename:Expression	signature:(Boolean val)
bool_const	cool-tree.h	/^Expression bool_const(Boolean);$/;"	p	typeref:typename:Expression	signature:(Boolean)
bool_const_class	cool-tree.h	/^   bool_const_class(Boolean a1) {$/;"	f	class:bool_const_class	access:public	signature:(Boolean a1)
bool_const_class	cool-tree.h	/^class bool_const_class : public Expression_class {$/;"	c	inherits:Expression_class
bool_const_class::bool_const_class	cool-tree.h	/^   bool_const_class(Boolean a1) {$/;"	f	class:bool_const_class	access:public	signature:(Boolean a1)
bool_const_class::code	cgen.cc	/^void bool_const_class::code(ostream& s)$/;"	f	class:bool_const_class	typeref:typename:void	signature:(ostream & s)
bool_const_class::copy_Expression	cool-tree.cc	/^Expression bool_const_class::copy_Expression()$/;"	f	class:bool_const_class	typeref:typename:Expression	signature:()
bool_const_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:bool_const_class	typeref:typename:Expression	access:public	signature:()
bool_const_class::dump	cool-tree.cc	/^void bool_const_class::dump(ostream& stream, int n)$/;"	f	class:bool_const_class	typeref:typename:void	signature:(ostream & stream,int n)
bool_const_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:bool_const_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
bool_const_class::dump_with_types	dumptype.cc	/^void bool_const_class::dump_with_types(ostream& stream, int n)$/;"	f	class:bool_const_class	typeref:typename:void	signature:(ostream & stream,int n)
bool_const_class::val	cool-tree.h	/^   Boolean val;$/;"	m	class:bool_const_class	typeref:typename:Boolean	access:protected
boolclasstag	cgen.h	/^		int boolclasstag;$/;"	m	class:CgenClassTable	typeref:typename:int	access:private
boolean	ast-parse.cc	/^  Boolean boolean;$/;"	m	union:YYSTYPE	typeref:typename:Boolean	file:	access:public
boolean	ast-parse.h	/^  Boolean boolean;$/;"	m	union:YYSTYPE	typeref:typename:Boolean	access:public
boolean	cool-parse.h	/^  Boolean boolean;$/;"	m	union:YYSTYPE	typeref:typename:Boolean	access:public
branch	cool-tree.cc	/^Case branch(Symbol name, Symbol type_decl, Expression expr)$/;"	f	typeref:typename:Case	signature:(Symbol name,Symbol type_decl,Expression expr)
branch	cool-tree.h	/^Case branch(Symbol, Symbol, Expression);$/;"	p	typeref:typename:Case	signature:(Symbol,Symbol,Expression)
branch_EXTRAS	cool-tree.handcode.h	/^#define branch_EXTRAS /;"	d
branch_class	cool-tree.h	/^   branch_class(Symbol a1, Symbol a2, Expression a3) {$/;"	f	class:branch_class	access:public	signature:(Symbol a1,Symbol a2,Expression a3)
branch_class	cool-tree.h	/^class branch_class : public Case_class {$/;"	c	inherits:Case_class
branch_class::branch_class	cool-tree.h	/^   branch_class(Symbol a1, Symbol a2, Expression a3) {$/;"	f	class:branch_class	access:public	signature:(Symbol a1,Symbol a2,Expression a3)
branch_class::copy_Case	cool-tree.cc	/^Case branch_class::copy_Case()$/;"	f	class:branch_class	typeref:typename:Case	signature:()
branch_class::copy_Case	cool-tree.h	/^   Case copy_Case();$/;"	p	class:branch_class	typeref:typename:Case	access:public	signature:()
branch_class::dump	cool-tree.cc	/^void branch_class::dump(ostream& stream, int n)$/;"	f	class:branch_class	typeref:typename:void	signature:(ostream & stream,int n)
branch_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:branch_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
branch_class::dump_with_types	dumptype.cc	/^void branch_class::dump_with_types(ostream& stream, int n)$/;"	f	class:branch_class	typeref:typename:void	signature:(ostream & stream,int n)
branch_class::expr	cool-tree.h	/^   Expression expr;$/;"	m	class:branch_class	typeref:typename:Expression	access:protected
branch_class::name	cool-tree.h	/^   Symbol name;$/;"	m	class:branch_class	typeref:typename:Symbol	access:protected
branch_class::type_decl	cool-tree.h	/^   Symbol type_decl;$/;"	m	class:branch_class	typeref:typename:Symbol	access:protected
build_inheritance_tree	cgen.cc	/^void CgenClassTable::build_inheritance_tree()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
build_inheritance_tree	cgen.h	/^		void build_inheritance_tree();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
byte_mode	cgen_supp.cc	/^void byte_mode(ostream& str)$/;"	f	typeref:typename:void	signature:(ostream & str)
case_	ast-parse.cc	/^  Case case_;$/;"	m	union:YYSTYPE	typeref:typename:Case	file:	access:public
case_	ast-parse.h	/^  Case case_;$/;"	m	union:YYSTYPE	typeref:typename:Case	access:public
case_	cool-parse.h	/^  Case case_;$/;"	m	union:YYSTYPE	typeref:typename:Case	access:public
cases	ast-parse.cc	/^  Cases cases;$/;"	m	union:YYSTYPE	typeref:typename:Cases	file:	access:public
cases	ast-parse.h	/^  Cases cases;$/;"	m	union:YYSTYPE	typeref:typename:Cases	access:public
cases	cool-parse.h	/^  Cases cases;$/;"	m	union:YYSTYPE	typeref:typename:Cases	access:public
cases	cool-tree.h	/^   Cases cases;$/;"	m	class:typcase_class	typeref:typename:Cases	access:protected
cgen	Makefile	/^cgen:	${OBJS} parser semant$/;"	t
cgen	cgen.cc	/^void program_class::cgen(ostream &os) $/;"	f	class:program_class	typeref:typename:void	signature:(ostream & os)
cgen_Memmgr	handle_flags.cc	/^       Memmgr cgen_Memmgr = GC_NOGC;      \/\/ enable\/disable garbage collection$/;"	v	typeref:typename:Memmgr
cgen_Memmgr_Debug	handle_flags.cc	/^       Memmgr_Debug cgen_Memmgr_Debug = GC_QUICK; \/\/ check heap frequently$/;"	v	typeref:typename:Memmgr_Debug
cgen_Memmgr_Test	handle_flags.cc	/^       Memmgr_Test cgen_Memmgr_Test = GC_NORMAL;  \/\/ normal\/test GC$/;"	v	typeref:typename:Memmgr_Test
cgen_debug	handle_flags.cc	/^       int cgen_debug;          \/\/ for code gen$/;"	v	typeref:typename:int
cgen_optimize	handle_flags.cc	/^       int cgen_optimize;       \/\/ optimize switch for code generator $/;"	v	typeref:typename:int
change-prot	Makefile	/^change-prot:$/;"	t
children	cgen.h	/^		List<CgenNode> *children;                  \/\/ Children of class$/;"	m	class:CgenNode	typeref:typename:List<CgenNode> *	access:private
class_	ast-parse.cc	/^  Class_ class_;$/;"	m	union:YYSTYPE	typeref:typename:Class_	file:	access:public
class_	ast-parse.h	/^  Class_ class_;$/;"	m	union:YYSTYPE	typeref:typename:Class_	access:public
class_	cool-parse.h	/^  Class_ class_;$/;"	m	union:YYSTYPE	typeref:typename:Class_	access:public
class_	cool-tree.cc	/^Class_ class_(Symbol name, Symbol parent, Features features, Symbol filename)$/;"	f	typeref:typename:Class_	signature:(Symbol name,Symbol parent,Features features,Symbol filename)
class_	cool-tree.h	/^Class_ class_(Symbol, Symbol, Features, Symbol);$/;"	p	typeref:typename:Class_	signature:(Symbol,Symbol,Features,Symbol)
class__EXTRAS	cool-tree.handcode.h	/^#define class__EXTRAS /;"	d
class__class	cool-tree.h	/^   class__class(Symbol a1, Symbol a2, Features a3, Symbol a4) {$/;"	f	class:class__class	access:public	signature:(Symbol a1,Symbol a2,Features a3,Symbol a4)
class__class	cool-tree.h	/^class class__class : public Class__class {$/;"	c	inherits:Class__class
class__class::class__class	cool-tree.h	/^   class__class(Symbol a1, Symbol a2, Features a3, Symbol a4) {$/;"	f	class:class__class	access:public	signature:(Symbol a1,Symbol a2,Features a3,Symbol a4)
class__class::copy_Class_	cool-tree.cc	/^Class_ class__class::copy_Class_()$/;"	f	class:class__class	typeref:typename:Class_	signature:()
class__class::copy_Class_	cool-tree.h	/^   Class_ copy_Class_();$/;"	p	class:class__class	typeref:typename:Class_	access:public	signature:()
class__class::dump	cool-tree.cc	/^void class__class::dump(ostream& stream, int n)$/;"	f	class:class__class	typeref:typename:void	signature:(ostream & stream,int n)
class__class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:class__class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
class__class::dump_with_types	dumptype.cc	/^void class__class::dump_with_types(ostream& stream, int n)$/;"	f	class:class__class	typeref:typename:void	signature:(ostream & stream,int n)
class__class::features	cool-tree.h	/^   Features features;$/;"	m	class:class__class	typeref:typename:Features	access:protected
class__class::filename	cool-tree.h	/^   Symbol filename;$/;"	m	class:class__class	typeref:typename:Symbol	access:protected
class__class::name	cool-tree.h	/^   Symbol name;$/;"	m	class:class__class	typeref:typename:Symbol	access:protected
class__class::parent	cool-tree.h	/^   Symbol parent;$/;"	m	class:class__class	typeref:typename:Symbol	access:protected
class_tags	cgen.cc	/^std::map<Symbol, int> class_tags;$/;"	v	typeref:typename:std::map<Symbol,int>
classes	ast-parse.cc	/^  Classes classes;$/;"	m	union:YYSTYPE	typeref:typename:Classes	file:	access:public
classes	ast-parse.h	/^  Classes classes;$/;"	m	union:YYSTYPE	typeref:typename:Classes	access:public
classes	cool-parse.h	/^  Classes classes;$/;"	m	union:YYSTYPE	typeref:typename:Classes	access:public
classes	cool-tree.h	/^   Classes classes;$/;"	m	class:program_class	typeref:typename:Classes	access:protected
clean	Makefile	/^clean :$/;"	t
clean-compile	Makefile	/^clean-compile:$/;"	t
code	cgen.cc	/^void CgenClassTable::code()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
code	cgen.cc	/^void assign_class::code(ostream &s) {$/;"	f	class:assign_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void attr_class::code(ostream &s) {}$/;"	f	class:attr_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void block_class::code(ostream &s) {$/;"	f	class:block_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void bool_const_class::code(ostream& s)$/;"	f	class:bool_const_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void comp_class::code(ostream &s) {$/;"	f	class:comp_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void cond_class::code(ostream &s) {$/;"	f	class:cond_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void dispatch_class::code(ostream &s) {$/;"	f	class:dispatch_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void divide_class::code(ostream &s) {$/;"	f	class:divide_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void eq_class::code(ostream &s) {$/;"	f	class:eq_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void int_const_class::code(ostream& s)  $/;"	f	class:int_const_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void isvoid_class::code(ostream &s) {$/;"	f	class:isvoid_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void leq_class::code(ostream &s) {$/;"	f	class:leq_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void let_class::code(ostream &s) {$/;"	f	class:let_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void loop_class::code(ostream &s) {$/;"	f	class:loop_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void lt_class::code(ostream &s) {$/;"	f	class:lt_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void method_class::code(ostream &s) {$/;"	f	class:method_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void mul_class::code(ostream &s) {$/;"	f	class:mul_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void neg_class::code(ostream &s) {$/;"	f	class:neg_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void new__class::code(ostream &s) {$/;"	f	class:new__class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void no_expr_class::code(ostream &s) {$/;"	f	class:no_expr_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void object_class::code(ostream &s) {$/;"	f	class:object_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void plus_class::code(ostream &s) {$/;"	f	class:plus_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void static_dispatch_class::code(ostream &s) {$/;"	f	class:static_dispatch_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void string_const_class::code(ostream& s)$/;"	f	class:string_const_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void sub_class::code(ostream &s) {$/;"	f	class:sub_class	typeref:typename:void	signature:(ostream & s)
code	cgen.cc	/^void typcase_class::code(ostream &s) {$/;"	f	class:typcase_class	typeref:typename:void	signature:(ostream & s)
code	cgen.h	/^		void code();$/;"	p	class:CgenClassTable	typeref:typename:void	access:public	signature:()
code_bools	cgen.cc	/^void CgenClassTable::code_bools(int boolclasstag)$/;"	f	class:CgenClassTable	typeref:typename:void	signature:(int boolclasstag)
code_bools	cgen.h	/^		void code_bools(int);$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:(int)
code_class_dispTab	cgen.cc	/^void CgenClassTable::code_class_dispTab()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
code_class_dispTab	cgen.h	/^		void code_class_dispTab();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
code_class_init	cgen.cc	/^void CgenClassTable::code_class_init() { root()->code_init(str); }$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
code_class_init	cgen.h	/^		void code_class_init();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
code_class_nameTab	cgen.cc	/^void CgenClassTable::code_class_nameTab()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
code_class_nameTab	cgen.h	/^		void code_class_nameTab();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
code_class_objTab	cgen.cc	/^void CgenClassTable::code_class_objTab()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
code_class_objTab	cgen.h	/^		void code_class_objTab();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
code_class_protObj	cgen.cc	/^void CgenClassTable::code_class_protObj() {$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
code_class_protObj	cgen.h	/^		void code_class_protObj();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
code_constants	cgen.cc	/^void CgenClassTable::code_constants()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
code_constants	cgen.h	/^		void code_constants();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
code_def	cgen.cc	/^void BoolConst::code_def(ostream& s, int boolclasstag)$/;"	f	class:BoolConst	typeref:typename:void	signature:(ostream & s,int boolclasstag)
code_def	cgen.cc	/^void IntEntry::code_def(ostream &s, int intclasstag)$/;"	f	class:IntEntry	typeref:typename:void	signature:(ostream & s,int intclasstag)
code_def	cgen.cc	/^void StringEntry::code_def(ostream& s, int stringclasstag)$/;"	f	class:StringEntry	typeref:typename:void	signature:(ostream & s,int stringclasstag)
code_def	cgen.h	/^		void code_def(ostream&, int boolclasstag);$/;"	p	class:BoolConst	typeref:typename:void	access:public	signature:(ostream &,int boolclasstag)
code_def	stringtab.h	/^		void code_def(ostream& str, int intclasstag);$/;"	p	class:IntEntry	typeref:typename:void	access:public	signature:(ostream & str,int intclasstag)
code_def	stringtab.h	/^		void code_def(ostream& str, int stringclasstag);$/;"	p	class:StringEntry	typeref:typename:void	access:public	signature:(ostream & str,int stringclasstag)
code_dispTab	cgen.cc	/^void CgenNode::code_dispTab(std::vector<std::pair<Symbol, Symbol>> mp, ostream &s)$/;"	f	class:CgenNode	typeref:typename:void	signature:(std::vector<std::pair<Symbol,Symbol>> mp,ostream & s)
code_dispTab	cgen.h	/^		void code_dispTab(std::vector<std::pair<Symbol, Symbol>>, ostream &);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(std::vector<std::pair<Symbol,Symbol>>,ostream &)
code_global_data	cgen.cc	/^void CgenClassTable::code_global_data()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
code_global_data	cgen.h	/^		void code_global_data();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
code_global_text	cgen.cc	/^void CgenClassTable::code_global_text()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
code_global_text	cgen.h	/^		void code_global_text();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
code_init	cgen.cc	/^void CgenNode::code_init(ostream &s) {$/;"	f	class:CgenNode	typeref:typename:void	signature:(ostream & s)
code_init	cgen.h	/^		void code_init(ostream &);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(ostream &)
code_method	cgen.cc	/^void CgenNode::code_method(ostream &s) {$/;"	f	class:CgenNode	typeref:typename:void	signature:(ostream & s)
code_method	cgen.h	/^		void code_method(ostream &);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(ostream &)
code_methods_init	cgen.cc	/^void CgenClassTable::code_methods_init() {$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
code_methods_init	cgen.h	/^		void code_methods_init();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
code_nameTab	cgen.cc	/^void CgenNode::code_nameTab(int &nodesize, ostream &s)$/;"	f	class:CgenNode	typeref:typename:void	signature:(int & nodesize,ostream & s)
code_nameTab	cgen.h	/^		void code_nameTab(int &, ostream &);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(int &,ostream &)
code_objTab	cgen.cc	/^void CgenNode::code_objTab(ostream &s)$/;"	f	class:CgenNode	typeref:typename:void	signature:(ostream & s)
code_objTab	cgen.h	/^		void code_objTab(ostream &);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(ostream &)
code_protObj	cgen.cc	/^void CgenNode::code_protObj(std::vector<Symbol> mp, ostream &s) {$/;"	f	class:CgenNode	typeref:typename:void	signature:(std::vector<Symbol> mp,ostream & s)
code_protObj	cgen.h	/^		void code_protObj(std::vector<Symbol>, ostream &);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(std::vector<Symbol>,ostream &)
code_ref	cgen.cc	/^void BoolConst::code_ref(ostream& s) const$/;"	f	class:BoolConst	typeref:typename:void	signature:(ostream & s) const
code_ref	cgen.cc	/^void IntEntry::code_ref(ostream &s)$/;"	f	class:IntEntry	typeref:typename:void	signature:(ostream & s)
code_ref	cgen.cc	/^void StringEntry::code_ref(ostream& s)$/;"	f	class:StringEntry	typeref:typename:void	signature:(ostream & s)
code_ref	cgen.h	/^		void code_ref(ostream&) const;$/;"	p	class:BoolConst	typeref:typename:void	access:public	signature:(ostream &) const
code_ref	stringtab.h	/^		void code_ref(ostream& str);$/;"	p	class:IntEntry	typeref:typename:void	access:public	signature:(ostream & str)
code_ref	stringtab.h	/^		void code_ref(ostream& str);$/;"	p	class:StringEntry	typeref:typename:void	access:public	signature:(ostream & str)
code_select_gc	cgen.cc	/^void CgenClassTable::code_select_gc()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
code_select_gc	cgen.h	/^		void code_select_gc();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
code_string_table	cgen.cc	/^void IntTable::code_string_table(ostream &s, int intclasstag)$/;"	f	class:IntTable	typeref:typename:void	signature:(ostream & s,int intclasstag)
code_string_table	cgen.cc	/^void StrTable::code_string_table(ostream& s, int stringclasstag)$/;"	f	class:StrTable	typeref:typename:void	signature:(ostream & s,int stringclasstag)
code_string_table	stringtab.h	/^		void code_string_table(ostream&, int classtag);$/;"	p	class:IntTable	typeref:typename:void	access:public	signature:(ostream &,int classtag)
code_string_table	stringtab.h	/^		void code_string_table(ostream&, int classtag);$/;"	p	class:StrTable	typeref:typename:void	access:public	signature:(ostream &,int classtag)
codegen_classtable	cgen.cc	/^CgenClassTable *codegen_classtable = nullptr;$/;"	v	typeref:typename:CgenClassTable *
comp	cool-tree.cc	/^Expression comp(Expression e1)$/;"	f	typeref:typename:Expression	signature:(Expression e1)
comp	cool-tree.h	/^Expression comp(Expression);$/;"	p	typeref:typename:Expression	signature:(Expression)
comp_class	cool-tree.h	/^   comp_class(Expression a1) {$/;"	f	class:comp_class	access:public	signature:(Expression a1)
comp_class	cool-tree.h	/^class comp_class : public Expression_class {$/;"	c	inherits:Expression_class
comp_class::code	cgen.cc	/^void comp_class::code(ostream &s) {$/;"	f	class:comp_class	typeref:typename:void	signature:(ostream & s)
comp_class::comp_class	cool-tree.h	/^   comp_class(Expression a1) {$/;"	f	class:comp_class	access:public	signature:(Expression a1)
comp_class::copy_Expression	cool-tree.cc	/^Expression comp_class::copy_Expression()$/;"	f	class:comp_class	typeref:typename:Expression	signature:()
comp_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:comp_class	typeref:typename:Expression	access:public	signature:()
comp_class::dump	cool-tree.cc	/^void comp_class::dump(ostream& stream, int n)$/;"	f	class:comp_class	typeref:typename:void	signature:(ostream & stream,int n)
comp_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:comp_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
comp_class::dump_with_types	dumptype.cc	/^void comp_class::dump_with_types(ostream& stream, int n)$/;"	f	class:comp_class	typeref:typename:void	signature:(ostream & stream,int n)
comp_class::e1	cool-tree.h	/^   Expression e1;$/;"	m	class:comp_class	typeref:typename:Expression	access:protected
compile	Makefile	/^compile:	cgen change-prot$/;"	t
concat	cgen.cc	/^	concat,$/;"	v	typeref:typename:Symbol
cond	cool-tree.cc	/^Expression cond(Expression pred, Expression then_exp, Expression else_exp)$/;"	f	typeref:typename:Expression	signature:(Expression pred,Expression then_exp,Expression else_exp)
cond	cool-tree.h	/^Expression cond(Expression, Expression, Expression);$/;"	p	typeref:typename:Expression	signature:(Expression,Expression,Expression)
cond_class	cool-tree.h	/^   cond_class(Expression a1, Expression a2, Expression a3) {$/;"	f	class:cond_class	access:public	signature:(Expression a1,Expression a2,Expression a3)
cond_class	cool-tree.h	/^class cond_class : public Expression_class {$/;"	c	inherits:Expression_class
cond_class::code	cgen.cc	/^void cond_class::code(ostream &s) {$/;"	f	class:cond_class	typeref:typename:void	signature:(ostream & s)
cond_class::cond_class	cool-tree.h	/^   cond_class(Expression a1, Expression a2, Expression a3) {$/;"	f	class:cond_class	access:public	signature:(Expression a1,Expression a2,Expression a3)
cond_class::copy_Expression	cool-tree.cc	/^Expression cond_class::copy_Expression()$/;"	f	class:cond_class	typeref:typename:Expression	signature:()
cond_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:cond_class	typeref:typename:Expression	access:public	signature:()
cond_class::dump	cool-tree.cc	/^void cond_class::dump(ostream& stream, int n)$/;"	f	class:cond_class	typeref:typename:void	signature:(ostream & stream,int n)
cond_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:cond_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
cond_class::dump_with_types	dumptype.cc	/^void cond_class::dump_with_types(ostream& stream, int n)$/;"	f	class:cond_class	typeref:typename:void	signature:(ostream & stream,int n)
cond_class::else_exp	cool-tree.h	/^   Expression else_exp;$/;"	m	class:cond_class	typeref:typename:Expression	access:protected
cond_class::pred	cool-tree.h	/^   Expression pred;$/;"	m	class:cond_class	typeref:typename:Expression	access:protected
cond_class::then_exp	cool-tree.h	/^   Expression then_exp;$/;"	m	class:cond_class	typeref:typename:Expression	access:protected
cons	tree.h	/^template <class Elem> append_node<Elem> *cons(Elem x, list_node<Elem> *l)$/;"	f	typeref:typename:append_node<Elem> *	signature:(Elem x,list_node<Elem> * l)
cons	tree.h	/^template <class Elem> append_node<Elem> *cons(Elem x, list_node<Elem> *l);$/;"	p	typeref:typename:append_node<Elem> *	signature:(Elem x,list_node<Elem> * l)
cool_abort	cgen.cc	/^	cool_abort,$/;"	v	typeref:typename:Symbol
cool_token_to_string	utilities.cc	/^char *cool_token_to_string(int tok)$/;"	f	typeref:typename:char *	signature:(int tok)
cool_token_to_string	utilities.h	/^extern char *cool_token_to_string(int tok);$/;"	p	typeref:typename:char *	signature:(int tok)
cool_yydebug	cgen-phase.cc	/^int cool_yydebug;     \/\/ not used, but needed to link with handle_flags$/;"	v	typeref:typename:int
cool_yylval	ast-lex.cc	/^YYSTYPE cool_yylval;  \/* needed to link ast code with utilities.cc *\/$/;"	v	typeref:typename:YYSTYPE
copy	cgen.cc	/^	copy,$/;"	v	typeref:typename:Symbol
copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Case(); }$/;"	f	class:Case_class	typeref:typename:tree_node *	access:public	signature:()
copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Class_(); }$/;"	f	class:Class__class	typeref:typename:tree_node *	access:public	signature:()
copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Expression(); }$/;"	f	class:Expression_class	typeref:typename:tree_node *	access:public	signature:()
copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Feature(); }$/;"	f	class:Feature_class	typeref:typename:tree_node *	access:public	signature:()
copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Formal(); }$/;"	f	class:Formal_class	typeref:typename:tree_node *	access:public	signature:()
copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Program(); }$/;"	f	class:Program_class	typeref:typename:tree_node *	access:public	signature:()
copy	tree.h	/^    tree_node *copy()            { return copy_list(); }$/;"	f	class:list_node	typeref:typename:tree_node *	access:public	signature:()
copy	tree.h	/^    virtual tree_node *copy() = 0;$/;"	p	class:tree_node	typeref:typename:tree_node *	access:public	signature:()
copy_Boolean	ast-parse.h	/^Boolean copy_Boolean(Boolean);$/;"	p	typeref:typename:Boolean	signature:(Boolean)
copy_Boolean	cool-parse.h	/^Boolean copy_Boolean(Boolean);$/;"	p	typeref:typename:Boolean	signature:(Boolean)
copy_Boolean	cool-tree.handcode.h	/^inline Boolean copy_Boolean(Boolean b) {return b; }$/;"	f	typeref:typename:Boolean	signature:(Boolean b)
copy_Boolean	cool.h	/^Boolean copy_Boolean(Boolean);$/;"	p	typeref:typename:Boolean	signature:(Boolean)
copy_Case	cool-tree.cc	/^Case branch_class::copy_Case()$/;"	f	class:branch_class	typeref:typename:Case	signature:()
copy_Case	cool-tree.h	/^   Case copy_Case();$/;"	p	class:branch_class	typeref:typename:Case	access:public	signature:()
copy_Case	cool-tree.h	/^   virtual Case copy_Case() = 0;$/;"	p	class:Case_class	typeref:typename:Case	access:public	signature:()
copy_Class_	cool-tree.cc	/^Class_ class__class::copy_Class_()$/;"	f	class:class__class	typeref:typename:Class_	signature:()
copy_Class_	cool-tree.h	/^   Class_ copy_Class_();$/;"	p	class:class__class	typeref:typename:Class_	access:public	signature:()
copy_Class_	cool-tree.h	/^   virtual Class_ copy_Class_() = 0;$/;"	p	class:Class__class	typeref:typename:Class_	access:public	signature:()
copy_Expression	cool-tree.cc	/^Expression assign_class::copy_Expression()$/;"	f	class:assign_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression block_class::copy_Expression()$/;"	f	class:block_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression bool_const_class::copy_Expression()$/;"	f	class:bool_const_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression comp_class::copy_Expression()$/;"	f	class:comp_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression cond_class::copy_Expression()$/;"	f	class:cond_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression dispatch_class::copy_Expression()$/;"	f	class:dispatch_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression divide_class::copy_Expression()$/;"	f	class:divide_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression eq_class::copy_Expression()$/;"	f	class:eq_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression int_const_class::copy_Expression()$/;"	f	class:int_const_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression isvoid_class::copy_Expression()$/;"	f	class:isvoid_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression leq_class::copy_Expression()$/;"	f	class:leq_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression let_class::copy_Expression()$/;"	f	class:let_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression loop_class::copy_Expression()$/;"	f	class:loop_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression lt_class::copy_Expression()$/;"	f	class:lt_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression mul_class::copy_Expression()$/;"	f	class:mul_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression neg_class::copy_Expression()$/;"	f	class:neg_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression new__class::copy_Expression()$/;"	f	class:new__class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression no_expr_class::copy_Expression()$/;"	f	class:no_expr_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression object_class::copy_Expression()$/;"	f	class:object_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression plus_class::copy_Expression()$/;"	f	class:plus_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression static_dispatch_class::copy_Expression()$/;"	f	class:static_dispatch_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression string_const_class::copy_Expression()$/;"	f	class:string_const_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression sub_class::copy_Expression()$/;"	f	class:sub_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.cc	/^Expression typcase_class::copy_Expression()$/;"	f	class:typcase_class	typeref:typename:Expression	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:assign_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:block_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:bool_const_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:comp_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:cond_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:dispatch_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:divide_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:eq_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:int_const_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:isvoid_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:leq_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:let_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:loop_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:lt_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:mul_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:neg_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:new__class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:no_expr_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:object_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:plus_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:static_dispatch_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:string_const_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:sub_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:typcase_class	typeref:typename:Expression	access:public	signature:()
copy_Expression	cool-tree.h	/^   virtual Expression copy_Expression() = 0;$/;"	p	class:Expression_class	typeref:typename:Expression	access:public	signature:()
copy_Feature	cool-tree.cc	/^Feature attr_class::copy_Feature()$/;"	f	class:attr_class	typeref:typename:Feature	signature:()
copy_Feature	cool-tree.cc	/^Feature method_class::copy_Feature()$/;"	f	class:method_class	typeref:typename:Feature	signature:()
copy_Feature	cool-tree.h	/^   Feature copy_Feature();$/;"	p	class:attr_class	typeref:typename:Feature	access:public	signature:()
copy_Feature	cool-tree.h	/^   Feature copy_Feature();$/;"	p	class:method_class	typeref:typename:Feature	access:public	signature:()
copy_Feature	cool-tree.h	/^   virtual Feature copy_Feature() = 0;$/;"	p	class:Feature_class	typeref:typename:Feature	access:public	signature:()
copy_Formal	cool-tree.cc	/^Formal formal_class::copy_Formal()$/;"	f	class:formal_class	typeref:typename:Formal	signature:()
copy_Formal	cool-tree.h	/^   Formal copy_Formal();$/;"	p	class:formal_class	typeref:typename:Formal	access:public	signature:()
copy_Formal	cool-tree.h	/^   virtual Formal copy_Formal() = 0;$/;"	p	class:Formal_class	typeref:typename:Formal	access:public	signature:()
copy_Program	cool-tree.cc	/^Program program_class::copy_Program()$/;"	f	class:program_class	typeref:typename:Program	signature:()
copy_Program	cool-tree.h	/^   Program copy_Program();$/;"	p	class:program_class	typeref:typename:Program	access:public	signature:()
copy_Program	cool-tree.h	/^   virtual Program copy_Program() = 0;$/;"	p	class:Program_class	typeref:typename:Program	access:public	signature:()
copy_Symbol	ast-parse.h	/^Symbol copy_Symbol(Symbol);$/;"	p	typeref:typename:Symbol	signature:(Symbol)
copy_Symbol	cool-parse.h	/^Symbol copy_Symbol(Symbol);$/;"	p	typeref:typename:Symbol	signature:(Symbol)
copy_Symbol	cool-tree.handcode.h	/^Symbol copy_Symbol(Symbol b);$/;"	p	typeref:typename:Symbol	signature:(Symbol b)
copy_Symbol	cool.h	/^Symbol copy_Symbol(Symbol);$/;"	p	typeref:typename:Symbol	signature:(Symbol)
copy_Symbol	stringtab.cc	/^Symbol copy_Symbol(const Symbol s)$/;"	f	typeref:typename:Symbol	signature:(const Symbol s)
copy_list	tree.h	/^    list_node<Elem> *copy_list();$/;"	p	class:append_node	typeref:typename:list_node<Elem> *	access:public	signature:()
copy_list	tree.h	/^    list_node<Elem> *copy_list();$/;"	p	class:nil_node	typeref:typename:list_node<Elem> *	access:public	signature:()
copy_list	tree.h	/^    list_node<Elem> *copy_list();$/;"	p	class:single_list_node	typeref:typename:list_node<Elem> *	access:public	signature:()
copy_list	tree.h	/^    virtual list_node<Elem> *copy_list() = 0;$/;"	p	class:list_node	typeref:typename:list_node<Elem> *	access:public	signature:()
copy_list	tree.h	/^template <class Elem> list_node<Elem> *append_node<Elem>::copy_list()$/;"	f	class:append_node	typeref:typename:list_node<Elem> *	signature:()
copy_list	tree.h	/^template <class Elem> list_node<Elem> *nil_node<Elem>::copy_list()$/;"	f	class:nil_node	typeref:typename:list_node<Elem> *	signature:()
copy_list	tree.h	/^template <class Elem> list_node<Elem> *single_list_node<Elem>::copy_list()$/;"	f	class:single_list_node	typeref:typename:list_node<Elem> *	signature:()
curr_filename	cgen-phase.cc	/^char *curr_filename;$/;"	v	typeref:typename:char *
current_class	cgen.cc	/^Symbol current_class;$/;"	v	typeref:typename:Symbol
current_line	ast-parse.cc	/^int current_line = 0;         \/* debugging, current line for input file *\/$/;"	v	typeref:typename:int
dest	ast-lex.cc	/^    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;$/;"	v	typeref:typename:register char *
disable_reg_alloc	handle_flags.cc	/^       bool disable_reg_alloc;  \/\/ Don't do register allocation$/;"	v	typeref:typename:bool
dispatch	cool-tree.cc	/^Expression dispatch(Expression expr, Symbol name, Expressions actual)$/;"	f	typeref:typename:Expression	signature:(Expression expr,Symbol name,Expressions actual)
dispatch	cool-tree.h	/^Expression dispatch(Expression, Symbol, Expressions);$/;"	p	typeref:typename:Expression	signature:(Expression,Symbol,Expressions)
dispatch_class	cool-tree.h	/^   dispatch_class(Expression a1, Symbol a2, Expressions a3) {$/;"	f	class:dispatch_class	access:public	signature:(Expression a1,Symbol a2,Expressions a3)
dispatch_class	cool-tree.h	/^class dispatch_class : public Expression_class {$/;"	c	inherits:Expression_class
dispatch_class::actual	cool-tree.h	/^   Expressions actual;$/;"	m	class:dispatch_class	typeref:typename:Expressions	access:protected
dispatch_class::code	cgen.cc	/^void dispatch_class::code(ostream &s) {$/;"	f	class:dispatch_class	typeref:typename:void	signature:(ostream & s)
dispatch_class::copy_Expression	cool-tree.cc	/^Expression dispatch_class::copy_Expression()$/;"	f	class:dispatch_class	typeref:typename:Expression	signature:()
dispatch_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:dispatch_class	typeref:typename:Expression	access:public	signature:()
dispatch_class::dispatch_class	cool-tree.h	/^   dispatch_class(Expression a1, Symbol a2, Expressions a3) {$/;"	f	class:dispatch_class	access:public	signature:(Expression a1,Symbol a2,Expressions a3)
dispatch_class::dump	cool-tree.cc	/^void dispatch_class::dump(ostream& stream, int n)$/;"	f	class:dispatch_class	typeref:typename:void	signature:(ostream & stream,int n)
dispatch_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:dispatch_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dispatch_class::dump_with_types	dumptype.cc	/^void dispatch_class::dump_with_types(ostream& stream, int n)$/;"	f	class:dispatch_class	typeref:typename:void	signature:(ostream & stream,int n)
dispatch_class::expr	cool-tree.h	/^   Expression expr;$/;"	m	class:dispatch_class	typeref:typename:Expression	access:protected
dispatch_class::name	cool-tree.h	/^   Symbol name;$/;"	m	class:dispatch_class	typeref:typename:Symbol	access:protected
divide	cool-tree.cc	/^Expression divide(Expression e1, Expression e2)$/;"	f	typeref:typename:Expression	signature:(Expression e1,Expression e2)
divide	cool-tree.h	/^Expression divide(Expression, Expression);$/;"	p	typeref:typename:Expression	signature:(Expression,Expression)
divide_class	cool-tree.h	/^   divide_class(Expression a1, Expression a2) {$/;"	f	class:divide_class	access:public	signature:(Expression a1,Expression a2)
divide_class	cool-tree.h	/^class divide_class : public Expression_class {$/;"	c	inherits:Expression_class
divide_class::code	cgen.cc	/^void divide_class::code(ostream &s) {$/;"	f	class:divide_class	typeref:typename:void	signature:(ostream & s)
divide_class::copy_Expression	cool-tree.cc	/^Expression divide_class::copy_Expression()$/;"	f	class:divide_class	typeref:typename:Expression	signature:()
divide_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:divide_class	typeref:typename:Expression	access:public	signature:()
divide_class::divide_class	cool-tree.h	/^   divide_class(Expression a1, Expression a2) {$/;"	f	class:divide_class	access:public	signature:(Expression a1,Expression a2)
divide_class::dump	cool-tree.cc	/^void divide_class::dump(ostream& stream, int n)$/;"	f	class:divide_class	typeref:typename:void	signature:(ostream & stream,int n)
divide_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:divide_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
divide_class::dump_with_types	dumptype.cc	/^void divide_class::dump_with_types(ostream& stream, int n)$/;"	f	class:divide_class	typeref:typename:void	signature:(ostream & stream,int n)
divide_class::e1	cool-tree.h	/^   Expression e1;$/;"	m	class:divide_class	typeref:typename:Expression	access:protected
divide_class::e2	cool-tree.h	/^   Expression e2;$/;"	m	class:divide_class	typeref:typename:Expression	access:protected
dotest	Makefile	/^dotest:	cgen example.cl$/;"	t
dump	cool-tree.cc	/^void assign_class::dump(ostream& stream, int n)$/;"	f	class:assign_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void attr_class::dump(ostream& stream, int n)$/;"	f	class:attr_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void block_class::dump(ostream& stream, int n)$/;"	f	class:block_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void bool_const_class::dump(ostream& stream, int n)$/;"	f	class:bool_const_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void branch_class::dump(ostream& stream, int n)$/;"	f	class:branch_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void class__class::dump(ostream& stream, int n)$/;"	f	class:class__class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void comp_class::dump(ostream& stream, int n)$/;"	f	class:comp_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void cond_class::dump(ostream& stream, int n)$/;"	f	class:cond_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void dispatch_class::dump(ostream& stream, int n)$/;"	f	class:dispatch_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void divide_class::dump(ostream& stream, int n)$/;"	f	class:divide_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void eq_class::dump(ostream& stream, int n)$/;"	f	class:eq_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void formal_class::dump(ostream& stream, int n)$/;"	f	class:formal_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void int_const_class::dump(ostream& stream, int n)$/;"	f	class:int_const_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void isvoid_class::dump(ostream& stream, int n)$/;"	f	class:isvoid_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void leq_class::dump(ostream& stream, int n)$/;"	f	class:leq_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void let_class::dump(ostream& stream, int n)$/;"	f	class:let_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void loop_class::dump(ostream& stream, int n)$/;"	f	class:loop_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void lt_class::dump(ostream& stream, int n)$/;"	f	class:lt_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void method_class::dump(ostream& stream, int n)$/;"	f	class:method_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void mul_class::dump(ostream& stream, int n)$/;"	f	class:mul_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void neg_class::dump(ostream& stream, int n)$/;"	f	class:neg_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void new__class::dump(ostream& stream, int n)$/;"	f	class:new__class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void no_expr_class::dump(ostream& stream, int n)$/;"	f	class:no_expr_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void object_class::dump(ostream& stream, int n)$/;"	f	class:object_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void plus_class::dump(ostream& stream, int n)$/;"	f	class:plus_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void program_class::dump(ostream& stream, int n)$/;"	f	class:program_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void static_dispatch_class::dump(ostream& stream, int n)$/;"	f	class:static_dispatch_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void string_const_class::dump(ostream& stream, int n)$/;"	f	class:string_const_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void sub_class::dump(ostream& stream, int n)$/;"	f	class:sub_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.cc	/^void typcase_class::dump(ostream& stream, int n)$/;"	f	class:typcase_class	typeref:typename:void	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:assign_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:attr_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:block_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:bool_const_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:branch_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:class__class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:comp_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:cond_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:dispatch_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:divide_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:eq_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:formal_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:int_const_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:isvoid_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:leq_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:let_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:loop_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:lt_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:method_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:mul_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:neg_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:new__class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:no_expr_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:object_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:plus_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:program_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:static_dispatch_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:string_const_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:sub_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:typcase_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	symtab.h	/^	void dump()$/;"	f	class:SymbolTable	typeref:typename:void	access:public	signature:()
dump	tree.h	/^    virtual void dump(ostream& stream, int n) = 0;$/;"	p	class:tree_node	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	tree.h	/^    void dump(ostream& stream, int n);$/;"	p	class:append_node	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	tree.h	/^    void dump(ostream& stream, int n);$/;"	p	class:nil_node	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	tree.h	/^    void dump(ostream& stream, int n);$/;"	p	class:single_list_node	typeref:typename:void	access:public	signature:(ostream & stream,int n)
dump	tree.h	/^template <class Elem> void append_node<Elem>::dump(ostream& stream, int n)$/;"	f	class:append_node	typeref:typename:void	signature:(ostream & stream,int n)
dump	tree.h	/^template <class Elem> void nil_node<Elem>::dump(ostream& stream, int n)$/;"	f	class:nil_node	typeref:typename:void	signature:(ostream & stream,int n)
dump	tree.h	/^template <class Elem> void single_list_node<Elem>::dump(ostream& stream, int n)$/;"	f	class:single_list_node	typeref:typename:void	signature:(ostream & stream,int n)
dump_Boolean	ast-parse.h	/^void dump_Boolean(ostream &,int,Boolean);$/;"	p	typeref:typename:void	signature:(ostream &,int,Boolean)
dump_Boolean	cool-parse.h	/^void dump_Boolean(ostream &,int,Boolean);$/;"	p	typeref:typename:void	signature:(ostream &,int,Boolean)
dump_Boolean	cool-tree.handcode.h	/^inline void dump_Boolean(ostream& stream, int padding, Boolean b)$/;"	f	typeref:typename:void	signature:(ostream & stream,int padding,Boolean b)
dump_Boolean	cool.h	/^void dump_Boolean(ostream &,int,Boolean);$/;"	p	typeref:typename:void	signature:(ostream &,int,Boolean)
dump_Boolean	dumptype.cc	/^void dump_Boolean(ostream& stream, int padding, Boolean b);$/;"	p	typeref:typename:void	file:	signature:(ostream & stream,int padding,Boolean b)
dump_Symbol	ast-parse.h	/^void dump_Symbol(ostream &,int,Symbol);$/;"	p	typeref:typename:void	signature:(ostream &,int,Symbol)
dump_Symbol	cool-parse.h	/^void dump_Symbol(ostream &,int,Symbol);$/;"	p	typeref:typename:void	signature:(ostream &,int,Symbol)
dump_Symbol	cool-tree.handcode.h	/^void dump_Symbol(ostream& stream, int padding, Symbol b);$/;"	p	typeref:typename:void	signature:(ostream & stream,int padding,Symbol b)
dump_Symbol	cool.h	/^void dump_Symbol(ostream &,int,Symbol);$/;"	p	typeref:typename:void	signature:(ostream &,int,Symbol)
dump_Symbol	dumptype.cc	/^void dump_Symbol(ostream& stream, int padding, Symbol b); $/;"	p	typeref:typename:void	file:	signature:(ostream & stream,int padding,Symbol b)
dump_Symbol	stringtab.cc	/^void dump_Symbol(ostream& s, int n, Symbol sym)$/;"	f	typeref:typename:void	signature:(ostream & s,int n,Symbol sym)
dump_cool_token	utilities.cc	/^void dump_cool_token(ostream& out, int lineno, int token, YYSTYPE yylval)$/;"	f	typeref:typename:void	signature:(ostream & out,int lineno,int token,YYSTYPE yylval)
dump_line	dumptype.cc	/^void dump_line(ostream& stream, int n, tree_node *t)$/;"	f	typeref:typename:void	signature:(ostream & stream,int n,tree_node * t)
dump_type	dumptype.cc	/^void Expression_class::dump_type(ostream& stream, int n)$/;"	f	class:Expression_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void assign_class::dump_with_types(ostream& stream, int n)$/;"	f	class:assign_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void attr_class::dump_with_types(ostream& stream, int n)$/;"	f	class:attr_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void block_class::dump_with_types(ostream& stream, int n)$/;"	f	class:block_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void bool_const_class::dump_with_types(ostream& stream, int n)$/;"	f	class:bool_const_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void branch_class::dump_with_types(ostream& stream, int n)$/;"	f	class:branch_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void class__class::dump_with_types(ostream& stream, int n)$/;"	f	class:class__class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void comp_class::dump_with_types(ostream& stream, int n)$/;"	f	class:comp_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void cond_class::dump_with_types(ostream& stream, int n)$/;"	f	class:cond_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void dispatch_class::dump_with_types(ostream& stream, int n)$/;"	f	class:dispatch_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void divide_class::dump_with_types(ostream& stream, int n)$/;"	f	class:divide_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void eq_class::dump_with_types(ostream& stream, int n)$/;"	f	class:eq_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void formal_class::dump_with_types(ostream& stream, int n)$/;"	f	class:formal_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void int_const_class::dump_with_types(ostream& stream, int n)$/;"	f	class:int_const_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void isvoid_class::dump_with_types(ostream& stream, int n)$/;"	f	class:isvoid_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void leq_class::dump_with_types(ostream& stream, int n)$/;"	f	class:leq_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void let_class::dump_with_types(ostream& stream, int n)$/;"	f	class:let_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void loop_class::dump_with_types(ostream& stream, int n)$/;"	f	class:loop_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void lt_class::dump_with_types(ostream& stream, int n)$/;"	f	class:lt_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void method_class::dump_with_types(ostream& stream, int n)$/;"	f	class:method_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void mul_class::dump_with_types(ostream& stream, int n)$/;"	f	class:mul_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void neg_class::dump_with_types(ostream& stream, int n)$/;"	f	class:neg_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void new__class::dump_with_types(ostream& stream, int n)$/;"	f	class:new__class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void no_expr_class::dump_with_types(ostream& stream, int n)$/;"	f	class:no_expr_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void object_class::dump_with_types(ostream& stream, int n)$/;"	f	class:object_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void plus_class::dump_with_types(ostream& stream, int n)$/;"	f	class:plus_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void program_class::dump_with_types(ostream& stream, int n)$/;"	f	class:program_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void static_dispatch_class::dump_with_types(ostream& stream, int n)$/;"	f	class:static_dispatch_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void string_const_class::dump_with_types(ostream& stream, int n)$/;"	f	class:string_const_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void sub_class::dump_with_types(ostream& stream, int n)$/;"	f	class:sub_class	typeref:typename:void	signature:(ostream & stream,int n)
dump_with_types	dumptype.cc	/^void typcase_class::dump_with_types(ostream& stream, int n)$/;"	f	class:typcase_class	typeref:typename:void	signature:(ostream & stream,int n)
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:comp_class	typeref:typename:Expression	access:protected
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:divide_class	typeref:typename:Expression	access:protected
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:eq_class	typeref:typename:Expression	access:protected
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:isvoid_class	typeref:typename:Expression	access:protected
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:leq_class	typeref:typename:Expression	access:protected
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:lt_class	typeref:typename:Expression	access:protected
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:mul_class	typeref:typename:Expression	access:protected
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:neg_class	typeref:typename:Expression	access:protected
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:plus_class	typeref:typename:Expression	access:protected
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:sub_class	typeref:typename:Expression	access:protected
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:divide_class	typeref:typename:Expression	access:protected
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:eq_class	typeref:typename:Expression	access:protected
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:leq_class	typeref:typename:Expression	access:protected
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:lt_class	typeref:typename:Expression	access:protected
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:mul_class	typeref:typename:Expression	access:protected
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:plus_class	typeref:typename:Expression	access:protected
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:sub_class	typeref:typename:Expression	access:protected
elem	tree.h	/^    Elem elem;$/;"	m	class:single_list_node	typeref:typename:Elem	access:private
else_exp	cool-tree.h	/^   Expression else_exp;$/;"	m	class:cond_class	typeref:typename:Expression	access:protected
emit_add	cgen.cc	/^static void emit_add(char *dest, char *src1, char *src2, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest,char * src1,char * src2,ostream & s)
emit_addiu	cgen.cc	/^static void emit_addiu(char *dest, char *src1, int imm, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest,char * src1,int imm,ostream & s)
emit_addu	cgen.cc	/^static void emit_addu(char *dest, char *src1, char *src2, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest,char * src1,char * src2,ostream & s)
emit_beq	cgen.cc	/^static void emit_beq(char *src1, char *src2, int label, ostream &s)$/;"	f	typeref:typename:void	file:	signature:(char * src1,char * src2,int label,ostream & s)
emit_beqz	cgen.cc	/^static void emit_beqz(char *source, int label, ostream &s)$/;"	f	typeref:typename:void	file:	signature:(char * source,int label,ostream & s)
emit_bgti	cgen.cc	/^static void emit_bgti(char *src1, int imm, int label, ostream &s)$/;"	f	typeref:typename:void	file:	signature:(char * src1,int imm,int label,ostream & s)
emit_bleq	cgen.cc	/^static void emit_bleq(char *src1, char *src2, int label, ostream &s)$/;"	f	typeref:typename:void	file:	signature:(char * src1,char * src2,int label,ostream & s)
emit_blt	cgen.cc	/^static void emit_blt(char *src1, char *src2, int label, ostream &s)$/;"	f	typeref:typename:void	file:	signature:(char * src1,char * src2,int label,ostream & s)
emit_blti	cgen.cc	/^static void emit_blti(char *src1, int imm, int label, ostream &s)$/;"	f	typeref:typename:void	file:	signature:(char * src1,int imm,int label,ostream & s)
emit_bne	cgen.cc	/^static void emit_bne(char *src1, char *src2, int label, ostream &s)$/;"	f	typeref:typename:void	file:	signature:(char * src1,char * src2,int label,ostream & s)
emit_branch	cgen.cc	/^static void emit_branch(int l, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(int l,ostream & s)
emit_disptable_ref	cgen.cc	/^static void emit_disptable_ref(Symbol sym, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(Symbol sym,ostream & s)
emit_div	cgen.cc	/^static void emit_div(char *dest, char *src1, char *src2, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest,char * src1,char * src2,ostream & s)
emit_fetch_int	cgen.cc	/^static void emit_fetch_int(char *dest, char *source, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest,char * source,ostream & s)
emit_gc_assign	cgen.cc	/^static void emit_gc_assign(ostream& s)$/;"	f	typeref:typename:void	file:	signature:(ostream & s)
emit_gc_check	cgen.cc	/^static void emit_gc_check(char *source, ostream &s)$/;"	f	typeref:typename:void	file:	signature:(char * source,ostream & s)
emit_init_ref	cgen.cc	/^static void emit_init_ref(Symbol sym, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(Symbol sym,ostream & s)
emit_jal	cgen.cc	/^static void emit_jal(char *address,ostream &s)$/;"	f	typeref:typename:void	file:	signature:(char * address,ostream & s)
emit_jalr	cgen.cc	/^static void emit_jalr(char *dest, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest,ostream & s)
emit_label_def	cgen.cc	/^static void emit_label_def(int l, ostream &s)$/;"	f	typeref:typename:void	file:	signature:(int l,ostream & s)
emit_label_ref	cgen.cc	/^static void emit_label_ref(int l, ostream &s)$/;"	f	typeref:typename:void	file:	signature:(int l,ostream & s)
emit_load	cgen.cc	/^static void emit_load(char *dest_reg, int offset, char *source_reg, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest_reg,int offset,char * source_reg,ostream & s)
emit_load_address	cgen.cc	/^static void emit_load_address(char *dest_reg, char *address, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest_reg,char * address,ostream & s)
emit_load_bool	cgen.cc	/^static void emit_load_bool(char *dest, const BoolConst& b, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest,const BoolConst & b,ostream & s)
emit_load_imm	cgen.cc	/^static void emit_load_imm(char *dest_reg, int val, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest_reg,int val,ostream & s)
emit_load_int	cgen.cc	/^static void emit_load_int(char *dest, IntEntry *i, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest,IntEntry * i,ostream & s)
emit_load_string	cgen.cc	/^static void emit_load_string(char *dest, StringEntry *str, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest,StringEntry * str,ostream & s)
emit_method_ref	cgen.cc	/^static void emit_method_ref(Symbol classname, Symbol methodname, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(Symbol classname,Symbol methodname,ostream & s)
emit_move	cgen.cc	/^static void emit_move(char *dest_reg, char *source_reg, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest_reg,char * source_reg,ostream & s)
emit_mul	cgen.cc	/^static void emit_mul(char *dest, char *src1, char *src2, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest,char * src1,char * src2,ostream & s)
emit_neg	cgen.cc	/^static void emit_neg(char *dest, char *src1, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest,char * src1,ostream & s)
emit_partial_load_address	cgen.cc	/^static void emit_partial_load_address(char *dest_reg, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest_reg,ostream & s)
emit_pop_stack	cgen.cc	/^static void emit_pop_stack(int argc, ostream &s) {$/;"	f	typeref:typename:void	file:	signature:(int argc,ostream & s)
emit_pop_temp	cgen.cc	/^static void emit_pop_temp(char *dest_reg, ostream &s) {$/;"	f	typeref:typename:void	file:	signature:(char * dest_reg,ostream & s)
emit_protobj_ref	cgen.cc	/^static void emit_protobj_ref(Symbol sym, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(Symbol sym,ostream & s)
emit_push	cgen.cc	/^static void emit_push(char *reg, ostream& str)$/;"	f	typeref:typename:void	file:	signature:(char * reg,ostream & str)
emit_push_stack	cgen.cc	/^static void emit_push_stack(int argc, ostream &s) {$/;"	f	typeref:typename:void	file:	signature:(int argc,ostream & s)
emit_return	cgen.cc	/^static void emit_return(ostream& s)$/;"	f	typeref:typename:void	file:	signature:(ostream & s)
emit_sll	cgen.cc	/^static void emit_sll(char *dest, char *src1, int num, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest,char * src1,int num,ostream & s)
emit_store	cgen.cc	/^static void emit_store(char *source_reg, int offset, char *dest_reg, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * source_reg,int offset,char * dest_reg,ostream & s)
emit_store_int	cgen.cc	/^static void emit_store_int(char *source, char *dest, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * source,char * dest,ostream & s)
emit_string_constant	cgen.cc	/^extern void emit_string_constant(ostream& str, char *s);$/;"	p	typeref:typename:void	file:	signature:(ostream & str,char * s)
emit_string_constant	cgen_supp.cc	/^void emit_string_constant(ostream& str, char* s)$/;"	f	typeref:typename:void	signature:(ostream & str,char * s)
emit_sub	cgen.cc	/^static void emit_sub(char *dest, char *src1, char *src2, ostream& s)$/;"	f	typeref:typename:void	file:	signature:(char * dest,char * src1,char * src2,ostream & s)
emit_test_collector	cgen.cc	/^static void emit_test_collector(ostream &s)$/;"	f	typeref:typename:void	file:	signature:(ostream & s)
enterscope	symtab.h	/^	void enterscope()$/;"	f	class:SymbolTable	typeref:typename:void	access:public	signature:()
env	cgen.cc	/^Environment env;$/;"	v	typeref:typename:Environment
eq	cool-tree.cc	/^Expression eq(Expression e1, Expression e2)$/;"	f	typeref:typename:Expression	signature:(Expression e1,Expression e2)
eq	cool-tree.h	/^Expression eq(Expression, Expression);$/;"	p	typeref:typename:Expression	signature:(Expression,Expression)
eq_class	cool-tree.h	/^   eq_class(Expression a1, Expression a2) {$/;"	f	class:eq_class	access:public	signature:(Expression a1,Expression a2)
eq_class	cool-tree.h	/^class eq_class : public Expression_class {$/;"	c	inherits:Expression_class
eq_class::code	cgen.cc	/^void eq_class::code(ostream &s) {$/;"	f	class:eq_class	typeref:typename:void	signature:(ostream & s)
eq_class::copy_Expression	cool-tree.cc	/^Expression eq_class::copy_Expression()$/;"	f	class:eq_class	typeref:typename:Expression	signature:()
eq_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:eq_class	typeref:typename:Expression	access:public	signature:()
eq_class::dump	cool-tree.cc	/^void eq_class::dump(ostream& stream, int n)$/;"	f	class:eq_class	typeref:typename:void	signature:(ostream & stream,int n)
eq_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:eq_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
eq_class::dump_with_types	dumptype.cc	/^void eq_class::dump_with_types(ostream& stream, int n)$/;"	f	class:eq_class	typeref:typename:void	signature:(ostream & stream,int n)
eq_class::e1	cool-tree.h	/^   Expression e1;$/;"	m	class:eq_class	typeref:typename:Expression	access:protected
eq_class::e2	cool-tree.h	/^   Expression e2;$/;"	m	class:eq_class	typeref:typename:Expression	access:protected
eq_class::eq_class	cool-tree.h	/^   eq_class(Expression a1, Expression a2) {$/;"	f	class:eq_class	access:public	signature:(Expression a1,Expression a2)
equal_index	stringtab.h	/^		bool equal_index(int ind) const           { return ind == index; }$/;"	f	class:Entry	typeref:typename:bool	access:public	signature:(int ind) const
equal_string	stringtab.cc	/^int Entry::equal_string(char *string, int length) const$/;"	f	class:Entry	typeref:typename:int	signature:(char * string,int length) const
equal_string	stringtab.h	/^		int equal_string(char *s, int len) const;  $/;"	p	class:Entry	typeref:typename:int	access:public	signature:(char * s,int len) const
error_msg	cool-parse.h	/^  char *error_msg;$/;"	m	union:YYSTYPE	typeref:typename:char *	access:public
execute	cgen.h	/^		void execute();$/;"	p	class:CgenClassTable	typeref:typename:void	access:public	signature:()
exitscope	symtab.h	/^	void exitscope()$/;"	f	class:SymbolTable	typeref:typename:void	access:public	signature:()
expr	cool-tree.h	/^   Expression expr;$/;"	m	class:assign_class	typeref:typename:Expression	access:protected
expr	cool-tree.h	/^   Expression expr;$/;"	m	class:branch_class	typeref:typename:Expression	access:protected
expr	cool-tree.h	/^   Expression expr;$/;"	m	class:dispatch_class	typeref:typename:Expression	access:protected
expr	cool-tree.h	/^   Expression expr;$/;"	m	class:method_class	typeref:typename:Expression	access:protected
expr	cool-tree.h	/^   Expression expr;$/;"	m	class:static_dispatch_class	typeref:typename:Expression	access:protected
expr	cool-tree.h	/^   Expression expr;$/;"	m	class:typcase_class	typeref:typename:Expression	access:protected
expression	ast-parse.cc	/^  Expression expression;$/;"	m	union:YYSTYPE	typeref:typename:Expression	file:	access:public
expression	ast-parse.h	/^  Expression expression;$/;"	m	union:YYSTYPE	typeref:typename:Expression	access:public
expression	cool-parse.h	/^  Expression expression;$/;"	m	union:YYSTYPE	typeref:typename:Expression	access:public
expressions	ast-parse.cc	/^  Expressions expressions;$/;"	m	union:YYSTYPE	typeref:typename:Expressions	file:	access:public
expressions	ast-parse.h	/^  Expressions expressions;$/;"	m	union:YYSTYPE	typeref:typename:Expressions	access:public
expressions	cool-parse.h	/^  Expressions expressions;$/;"	m	union:YYSTYPE	typeref:typename:Expressions	access:public
falsebool	cgen.cc	/^BoolConst falsebool(FALSE);$/;"	p	typeref:typename:BoolConst	file:	signature:(FALSE)
fatal_error	symtab.h	/^	void fatal_error(char * msg)$/;"	f	class:SymbolTable	typeref:typename:void	access:public	signature:(char * msg)
fatal_error	utilities.cc	/^void fatal_error(char *msg)$/;"	f	typeref:typename:void	signature:(char * msg)
fatal_error	utilities.h	/^extern void fatal_error(char *);$/;"	p	typeref:typename:void	signature:(char *)
feature	ast-parse.cc	/^  Feature feature;$/;"	m	union:YYSTYPE	typeref:typename:Feature	file:	access:public
feature	ast-parse.h	/^  Feature feature;$/;"	m	union:YYSTYPE	typeref:typename:Feature	access:public
feature	cool-parse.h	/^  Feature feature;$/;"	m	union:YYSTYPE	typeref:typename:Feature	access:public
features	ast-parse.cc	/^  Features features;$/;"	m	union:YYSTYPE	typeref:typename:Features	file:	access:public
features	ast-parse.h	/^  Features features;$/;"	m	union:YYSTYPE	typeref:typename:Features	access:public
features	cool-parse.h	/^  Features features;$/;"	m	union:YYSTYPE	typeref:typename:Features	access:public
features	cool-tree.h	/^   Features features;$/;"	m	class:class__class	typeref:typename:Features	access:protected
filename	cool-tree.h	/^   Symbol filename;$/;"	m	class:class__class	typeref:typename:Symbol	access:protected
files.associations	.vscode/settings.json	/^    "files.associations": {$/;"	o
find_method	cgen.cc	/^method_class *CgenNode::find_method(Symbol method_name) {$/;"	f	class:CgenNode	typeref:typename:method_class *	signature:(Symbol method_name)
find_method	cgen.h	/^		method_class *find_method(Symbol);$/;"	p	class:CgenNode	typeref:typename:method_class *	access:public	signature:(Symbol)
first	stringtab.h	/^		int first();       \/\/ first index$/;"	p	class:StringTable	typeref:typename:int	access:public	signature:()
first	stringtab_functions.h	/^int StringTable<Elem>::first()$/;"	f	class:StringTable	typeref:typename:int	signature:()
first	tree.h	/^    int first()      { return 0; }$/;"	f	class:list_node	typeref:typename:int	access:public	signature:()
first_column	cool-parse.h	/^  int first_column;$/;"	m	struct:YYLTYPE	typeref:typename:int	access:public
first_line	cool-parse.h	/^  int first_line;$/;"	m	struct:YYLTYPE	typeref:typename:int	access:public
flex_int16_t	ast-lex.cc	/^typedef int16_t flex_int16_t;$/;"	t	typeref:typename:int16_t	file:
flex_int16_t	ast-lex.cc	/^typedef short int flex_int16_t;$/;"	t	typeref:typename:short int	file:
flex_int32_t	ast-lex.cc	/^typedef int flex_int32_t;$/;"	t	typeref:typename:int	file:
flex_int32_t	ast-lex.cc	/^typedef int32_t flex_int32_t;$/;"	t	typeref:typename:int32_t	file:
flex_int8_t	ast-lex.cc	/^typedef int8_t flex_int8_t;$/;"	t	typeref:typename:int8_t	file:
flex_int8_t	ast-lex.cc	/^typedef signed char flex_int8_t;$/;"	t	typeref:typename:signed char	file:
flex_uint16_t	ast-lex.cc	/^typedef uint16_t flex_uint16_t;$/;"	t	typeref:typename:uint16_t	file:
flex_uint16_t	ast-lex.cc	/^typedef unsigned short int flex_uint16_t;$/;"	t	typeref:typename:unsigned short int	file:
flex_uint32_t	ast-lex.cc	/^typedef uint32_t flex_uint32_t;$/;"	t	typeref:typename:uint32_t	file:
flex_uint32_t	ast-lex.cc	/^typedef unsigned int flex_uint32_t;$/;"	t	typeref:typename:unsigned int	file:
flex_uint8_t	ast-lex.cc	/^typedef uint8_t flex_uint8_t;$/;"	t	typeref:typename:uint8_t	file:
flex_uint8_t	ast-lex.cc	/^typedef unsigned char flex_uint8_t; $/;"	t	typeref:typename:unsigned char	file:
formal	ast-parse.cc	/^  Formal formal;$/;"	m	union:YYSTYPE	typeref:typename:Formal	file:	access:public
formal	ast-parse.h	/^  Formal formal;$/;"	m	union:YYSTYPE	typeref:typename:Formal	access:public
formal	cool-parse.h	/^  Formal formal;$/;"	m	union:YYSTYPE	typeref:typename:Formal	access:public
formal	cool-tree.cc	/^Formal formal(Symbol name, Symbol type_decl)$/;"	f	typeref:typename:Formal	signature:(Symbol name,Symbol type_decl)
formal	cool-tree.h	/^Formal formal(Symbol, Symbol);$/;"	p	typeref:typename:Formal	signature:(Symbol,Symbol)
formal_EXTRAS	cool-tree.handcode.h	/^#define formal_EXTRAS /;"	d
formal_class	cool-tree.h	/^   formal_class(Symbol a1, Symbol a2) {$/;"	f	class:formal_class	access:public	signature:(Symbol a1,Symbol a2)
formal_class	cool-tree.h	/^class formal_class : public Formal_class {$/;"	c	inherits:Formal_class
formal_class::copy_Formal	cool-tree.cc	/^Formal formal_class::copy_Formal()$/;"	f	class:formal_class	typeref:typename:Formal	signature:()
formal_class::copy_Formal	cool-tree.h	/^   Formal copy_Formal();$/;"	p	class:formal_class	typeref:typename:Formal	access:public	signature:()
formal_class::dump	cool-tree.cc	/^void formal_class::dump(ostream& stream, int n)$/;"	f	class:formal_class	typeref:typename:void	signature:(ostream & stream,int n)
formal_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:formal_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
formal_class::dump_with_types	dumptype.cc	/^void formal_class::dump_with_types(ostream& stream, int n)$/;"	f	class:formal_class	typeref:typename:void	signature:(ostream & stream,int n)
formal_class::formal_class	cool-tree.h	/^   formal_class(Symbol a1, Symbol a2) {$/;"	f	class:formal_class	access:public	signature:(Symbol a1,Symbol a2)
formal_class::name	cool-tree.h	/^   Symbol name;$/;"	m	class:formal_class	typeref:typename:Symbol	access:protected
formal_class::type_decl	cool-tree.h	/^   Symbol type_decl;$/;"	m	class:formal_class	typeref:typename:Symbol	access:protected
formals	ast-parse.cc	/^  Formals formals;$/;"	m	union:YYSTYPE	typeref:typename:Formals	file:	access:public
formals	ast-parse.h	/^  Formals formals;$/;"	m	union:YYSTYPE	typeref:typename:Formals	access:public
formals	cool-parse.h	/^  Formals formals;$/;"	m	union:YYSTYPE	typeref:typename:Formals	access:public
formals	cool-tree.h	/^   Formals formals;$/;"	m	class:method_class	typeref:typename:Formals	access:protected
free	ast-parse.cc	/^void free (void *); \/* INFRINGES ON USER NAME SPACE *\/$/;"	p	typeref:typename:void	file:	signature:(void *)
gc_collect_names	cgen.cc	/^static char *gc_collect_names[] =$/;"	v	typeref:typename:char * []	file:
gc_init_names	cgen.cc	/^static char *gc_init_names[] =$/;"	v	typeref:typename:char * []	file:
get_Argument	cgen.h	/^		int get_Argument(Symbol s) {$/;"	f	class:Environment	typeref:typename:int	access:public	signature:(Symbol s)
get_Attribute	cgen.h	/^		int get_Attribute(Symbol s) {$/;"	f	class:Environment	typeref:typename:int	access:public	signature:(Symbol s)
get_Var	cgen.h	/^		int get_Var(Symbol s) {$/;"	f	class:Environment	typeref:typename:int	access:public	signature:(Symbol s)
get_children	cgen.h	/^		List<CgenNode> *get_children() { return children; }$/;"	f	class:CgenNode	typeref:typename:List<CgenNode> *	access:public	signature:()
get_id	symtab.h	/^		SYM get_id() const    { return id; }$/;"	f	class:SymtabEntry	typeref:typename:SYM	access:public	signature:() const
get_info	symtab.h	/^		DAT *get_info() const { return info; }$/;"	f	class:SymtabEntry	typeref:typename:DAT *	access:public	signature:() const
get_len	stringtab.cc	/^int Entry::get_len() const$/;"	f	class:Entry	typeref:typename:int	signature:() const
get_len	stringtab.h	/^		int get_len() const;$/;"	p	class:Entry	typeref:typename:int	access:public	signature:() const
get_line_number	tree.cc	/^int tree_node::get_line_number()$/;"	f	class:tree_node	typeref:typename:int	signature:()
get_line_number	tree.h	/^    int get_line_number();$/;"	p	class:tree_node	typeref:typename:int	access:public	signature:()
get_parentnd	cgen.h	/^		CgenNodeP get_parentnd() { return parentnd; }$/;"	f	class:CgenNode	typeref:typename:CgenNodeP	access:public	signature:()
get_string	stringtab.cc	/^char *Entry::get_string() const$/;"	f	class:Entry	typeref:typename:char *	signature:() const
get_string	stringtab.h	/^		char *get_string() const;$/;"	p	class:Entry	typeref:typename:char *	access:public	signature:() const
handle_flags	cgen-phase.cc	/^void handle_flags(int argc, char *argv[]);$/;"	p	typeref:typename:void	file:	signature:(int argc,char * argv[])
handle_flags	handle_flags.cc	/^void handle_flags(int argc, char *argv[]) {$/;"	f	typeref:typename:void	signature:(int argc,char * argv[])
hd	list.h	/^  T *hd() const       { return head; }  $/;"	f	class:List	typeref:typename:T *	access:public	signature:() const
head	list.h	/^  T *head;$/;"	m	class:List	typeref:typename:T *	access:private
i	ast-lex.cc	/^	register int number_to_move, i;$/;"	v	typeref:typename:register int
id	symtab.h	/^		SYM id;        \/\/ the key field$/;"	m	class:SymtabEntry	typeref:typename:SYM	access:private
identifier	cool-tree.h	/^   Symbol identifier;$/;"	m	class:let_class	typeref:typename:Symbol	access:protected
idtable	stringtab.cc	/^IdTable idtable;$/;"	v	typeref:typename:IdTable
in_int	cgen.cc	/^	in_int,$/;"	v	typeref:typename:Symbol
in_string	cgen.cc	/^	in_string,$/;"	v	typeref:typename:Symbol
index	stringtab.h	/^		int index;         \/\/ the current index$/;"	m	class:StringTable	typeref:typename:int	access:protected
index	stringtab.h	/^		int index;     \/\/ a unique index for each string$/;"	m	class:Entry	typeref:typename:int	access:protected
info	symtab.h	/^		DAT *info;     \/\/ associated information for the symbol$/;"	m	class:SymtabEntry	typeref:typename:DAT *	access:private
init	cool-tree.h	/^   Expression init;$/;"	m	class:attr_class	typeref:typename:Expression	access:protected
init	cool-tree.h	/^   Expression init;$/;"	m	class:let_class	typeref:typename:Expression	access:protected
initialize_constants	cgen.cc	/^static void initialize_constants(void)$/;"	f	typeref:typename:void	file:	signature:(void)
input	ast-lex.cc	/^static int input (void );$/;"	p	typeref:typename:int	file:	signature:(void)
install_args	cgen.cc	/^void method_class::install_args() {$/;"	f	class:method_class	typeref:typename:void	signature:()
install_args	cgen.h	/^		void install_args(Symbol);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(Symbol)
install_basic_classes	cgen.cc	/^void CgenClassTable::install_basic_classes()$/;"	f	class:CgenClassTable	typeref:typename:void	signature:()
install_basic_classes	cgen.h	/^		void install_basic_classes();$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:()
install_class	cgen.cc	/^void CgenClassTable::install_class(CgenNodeP nd)$/;"	f	class:CgenClassTable	typeref:typename:void	signature:(CgenNodeP nd)
install_class	cgen.h	/^		void install_class(CgenNodeP nd);$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:(CgenNodeP nd)
install_classes	cgen.cc	/^void CgenClassTable::install_classes(Classes cs)$/;"	f	class:CgenClassTable	typeref:typename:void	signature:(Classes cs)
install_classes	cgen.h	/^		void install_classes(Classes cs);$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:(Classes cs)
int_const	cool-tree.cc	/^Expression int_const(Symbol token)$/;"	f	typeref:typename:Expression	signature:(Symbol token)
int_const	cool-tree.h	/^Expression int_const(Symbol);$/;"	p	typeref:typename:Expression	signature:(Symbol)
int_const_class	cool-tree.h	/^   int_const_class(Symbol a1) {$/;"	f	class:int_const_class	access:public	signature:(Symbol a1)
int_const_class	cool-tree.h	/^class int_const_class : public Expression_class {$/;"	c	inherits:Expression_class
int_const_class::code	cgen.cc	/^void int_const_class::code(ostream& s)  $/;"	f	class:int_const_class	typeref:typename:void	signature:(ostream & s)
int_const_class::copy_Expression	cool-tree.cc	/^Expression int_const_class::copy_Expression()$/;"	f	class:int_const_class	typeref:typename:Expression	signature:()
int_const_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:int_const_class	typeref:typename:Expression	access:public	signature:()
int_const_class::dump	cool-tree.cc	/^void int_const_class::dump(ostream& stream, int n)$/;"	f	class:int_const_class	typeref:typename:void	signature:(ostream & stream,int n)
int_const_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:int_const_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
int_const_class::dump_with_types	dumptype.cc	/^void int_const_class::dump_with_types(ostream& stream, int n)$/;"	f	class:int_const_class	typeref:typename:void	signature:(ostream & stream,int n)
int_const_class::int_const_class	cool-tree.h	/^   int_const_class(Symbol a1) {$/;"	f	class:int_const_class	access:public	signature:(Symbol a1)
int_const_class::token	cool-tree.h	/^   Symbol token;$/;"	m	class:int_const_class	typeref:typename:Symbol	access:protected
intclasstag	cgen.h	/^		int intclasstag;$/;"	m	class:CgenClassTable	typeref:typename:int	access:private
inttable	stringtab.cc	/^IntTable inttable;$/;"	v	typeref:typename:IntTable
isatty	ast-lex.cc	/^extern int isatty (int );$/;"	p	typeref:typename:int	file:	signature:(int)
isvoid	cool-tree.cc	/^Expression isvoid(Expression e1)$/;"	f	typeref:typename:Expression	signature:(Expression e1)
isvoid	cool-tree.h	/^Expression isvoid(Expression);$/;"	p	typeref:typename:Expression	signature:(Expression)
isvoid_class	cool-tree.h	/^   isvoid_class(Expression a1) {$/;"	f	class:isvoid_class	access:public	signature:(Expression a1)
isvoid_class	cool-tree.h	/^class isvoid_class : public Expression_class {$/;"	c	inherits:Expression_class
isvoid_class::code	cgen.cc	/^void isvoid_class::code(ostream &s) {$/;"	f	class:isvoid_class	typeref:typename:void	signature:(ostream & s)
isvoid_class::copy_Expression	cool-tree.cc	/^Expression isvoid_class::copy_Expression()$/;"	f	class:isvoid_class	typeref:typename:Expression	signature:()
isvoid_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:isvoid_class	typeref:typename:Expression	access:public	signature:()
isvoid_class::dump	cool-tree.cc	/^void isvoid_class::dump(ostream& stream, int n)$/;"	f	class:isvoid_class	typeref:typename:void	signature:(ostream & stream,int n)
isvoid_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:isvoid_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
isvoid_class::dump_with_types	dumptype.cc	/^void isvoid_class::dump_with_types(ostream& stream, int n)$/;"	f	class:isvoid_class	typeref:typename:void	signature:(ostream & stream,int n)
isvoid_class::e1	cool-tree.h	/^   Expression e1;$/;"	m	class:isvoid_class	typeref:typename:Expression	access:protected
isvoid_class::isvoid_class	cool-tree.h	/^   isvoid_class(Expression a1) {$/;"	f	class:isvoid_class	access:public	signature:(Expression a1)
label_num	cgen.cc	/^int label_num = 0, nodesize = 0;$/;"	v	typeref:typename:int
last_column	cool-parse.h	/^  int last_column;$/;"	m	struct:YYLTYPE	typeref:typename:int	access:public
last_line	cool-parse.h	/^  int last_line;$/;"	m	struct:YYLTYPE	typeref:typename:int	access:public
len	stringtab.h	/^		int  len;      \/\/ the length of the string (without trailing \\0)$/;"	m	class:Entry	typeref:typename:int	access:protected
len	tree.h	/^    int len();$/;"	p	class:append_node	typeref:typename:int	access:public	signature:()
len	tree.h	/^    int len();$/;"	p	class:nil_node	typeref:typename:int	access:public	signature:()
len	tree.h	/^    int len();$/;"	p	class:single_list_node	typeref:typename:int	access:public	signature:()
len	tree.h	/^    virtual int len() = 0;$/;"	p	class:list_node	typeref:typename:int	access:public	signature:()
len	tree.h	/^template <class Elem> int append_node<Elem>::len()$/;"	f	class:append_node	typeref:typename:int	signature:()
len	tree.h	/^template <class Elem> int nil_node<Elem>::len()$/;"	f	class:nil_node	typeref:typename:int	signature:()
len	tree.h	/^template <class Elem> int single_list_node<Elem>::len()$/;"	f	class:single_list_node	typeref:typename:int	signature:()
length	cgen.cc	/^	length,$/;"	v	typeref:typename:Symbol
leq	cool-tree.cc	/^Expression leq(Expression e1, Expression e2)$/;"	f	typeref:typename:Expression	signature:(Expression e1,Expression e2)
leq	cool-tree.h	/^Expression leq(Expression, Expression);$/;"	p	typeref:typename:Expression	signature:(Expression,Expression)
leq_class	cool-tree.h	/^   leq_class(Expression a1, Expression a2) {$/;"	f	class:leq_class	access:public	signature:(Expression a1,Expression a2)
leq_class	cool-tree.h	/^class leq_class : public Expression_class {$/;"	c	inherits:Expression_class
leq_class::code	cgen.cc	/^void leq_class::code(ostream &s) {$/;"	f	class:leq_class	typeref:typename:void	signature:(ostream & s)
leq_class::copy_Expression	cool-tree.cc	/^Expression leq_class::copy_Expression()$/;"	f	class:leq_class	typeref:typename:Expression	signature:()
leq_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:leq_class	typeref:typename:Expression	access:public	signature:()
leq_class::dump	cool-tree.cc	/^void leq_class::dump(ostream& stream, int n)$/;"	f	class:leq_class	typeref:typename:void	signature:(ostream & stream,int n)
leq_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:leq_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
leq_class::dump_with_types	dumptype.cc	/^void leq_class::dump_with_types(ostream& stream, int n)$/;"	f	class:leq_class	typeref:typename:void	signature:(ostream & stream,int n)
leq_class::e1	cool-tree.h	/^   Expression e1;$/;"	m	class:leq_class	typeref:typename:Expression	access:protected
leq_class::e2	cool-tree.h	/^   Expression e2;$/;"	m	class:leq_class	typeref:typename:Expression	access:protected
leq_class::leq_class	cool-tree.h	/^   leq_class(Expression a1, Expression a2) {$/;"	f	class:leq_class	access:public	signature:(Expression a1,Expression a2)
let	cool-tree.cc	/^Expression let(Symbol identifier, Symbol type_decl, Expression init, Expression body)$/;"	f	typeref:typename:Expression	signature:(Symbol identifier,Symbol type_decl,Expression init,Expression body)
let	cool-tree.h	/^Expression let(Symbol, Symbol, Expression, Expression);$/;"	p	typeref:typename:Expression	signature:(Symbol,Symbol,Expression,Expression)
let_class	cool-tree.h	/^   let_class(Symbol a1, Symbol a2, Expression a3, Expression a4) {$/;"	f	class:let_class	access:public	signature:(Symbol a1,Symbol a2,Expression a3,Expression a4)
let_class	cool-tree.h	/^class let_class : public Expression_class {$/;"	c	inherits:Expression_class
let_class::body	cool-tree.h	/^   Expression body;$/;"	m	class:let_class	typeref:typename:Expression	access:protected
let_class::code	cgen.cc	/^void let_class::code(ostream &s) {$/;"	f	class:let_class	typeref:typename:void	signature:(ostream & s)
let_class::copy_Expression	cool-tree.cc	/^Expression let_class::copy_Expression()$/;"	f	class:let_class	typeref:typename:Expression	signature:()
let_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:let_class	typeref:typename:Expression	access:public	signature:()
let_class::dump	cool-tree.cc	/^void let_class::dump(ostream& stream, int n)$/;"	f	class:let_class	typeref:typename:void	signature:(ostream & stream,int n)
let_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:let_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
let_class::dump_with_types	dumptype.cc	/^void let_class::dump_with_types(ostream& stream, int n)$/;"	f	class:let_class	typeref:typename:void	signature:(ostream & stream,int n)
let_class::identifier	cool-tree.h	/^   Symbol identifier;$/;"	m	class:let_class	typeref:typename:Symbol	access:protected
let_class::init	cool-tree.h	/^   Expression init;$/;"	m	class:let_class	typeref:typename:Expression	access:protected
let_class::let_class	cool-tree.h	/^   let_class(Symbol a1, Symbol a2, Expression a3, Expression a4) {$/;"	f	class:let_class	access:public	signature:(Symbol a1,Symbol a2,Expression a3,Expression a4)
let_class::type_decl	cool-tree.h	/^   Symbol type_decl;$/;"	m	class:let_class	typeref:typename:Symbol	access:protected
lex_verbose	handle_flags.cc	/^       int lex_verbose;         \/\/ also for the lexer; prints tokens$/;"	v	typeref:typename:int
line_number	tree.h	/^    int line_number;            \/\/ stash the line number when node is made$/;"	m	class:tree_node	typeref:typename:int	access:protected
lineno	ast-parse.cc	/^  int lineno;$/;"	m	union:YYSTYPE	typeref:typename:int	file:	access:public
lineno	ast-parse.h	/^  int lineno;$/;"	m	union:YYSTYPE	typeref:typename:int	access:public
list	tree.h	/^template <class Elem> single_list_node<Elem> *list(Elem x)$/;"	f	typeref:typename:single_list_node<Elem> *	signature:(Elem x)
list	tree.h	/^template <class Elem> single_list_node<Elem> *list(Elem x);$/;"	p	typeref:typename:single_list_node<Elem> *	signature:(Elem x)
list_length	list.h	/^int list_length(List<T> *l)$/;"	f	typeref:typename:int	signature:(List<T> * l)
list_map	list.h	/^void list_map(void f(T*), List<T> *l)$/;"	f	typeref:typename:void	signature:(void f (T *),List<T> * l)
list_node	tree.h	/^template <class Elem> class list_node : public tree_node {$/;"	c	inherits:tree_node
list_node::append	tree.h	/^    static list_node<Elem> *append(list_node<Elem> *l1,list_node<Elem> *l2);$/;"	p	class:list_node	typeref:typename:list_node<Elem> *	access:public	signature:(list_node<Elem> * l1,list_node<Elem> * l2)
list_node::append	tree.h	/^template <class Elem> list_node<Elem> *list_node<Elem>::append(list_node<Elem> *l1,list_node<Ele/;"	f	class:list_node	typeref:typename:list_node<Elem> *	signature:(list_node<Elem> * l1,list_node<Elem> * l2)
list_node::copy	tree.h	/^    tree_node *copy()            { return copy_list(); }$/;"	f	class:list_node	typeref:typename:tree_node *	access:public	signature:()
list_node::copy_list	tree.h	/^    virtual list_node<Elem> *copy_list() = 0;$/;"	p	class:list_node	typeref:typename:list_node<Elem> *	access:public	signature:()
list_node::first	tree.h	/^    int first()      { return 0; }$/;"	f	class:list_node	typeref:typename:int	access:public	signature:()
list_node::len	tree.h	/^    virtual int len() = 0;$/;"	p	class:list_node	typeref:typename:int	access:public	signature:()
list_node::more	tree.h	/^    int more(int n)  { return (n < len()); }$/;"	f	class:list_node	typeref:typename:int	access:public	signature:(int n)
list_node::next	tree.h	/^    int next(int n)  { return n + 1; }$/;"	f	class:list_node	typeref:typename:int	access:public	signature:(int n)
list_node::nil	tree.h	/^    static list_node<Elem> *nil();$/;"	p	class:list_node	typeref:typename:list_node<Elem> *	access:public	signature:()
list_node::nil	tree.h	/^template <class Elem> list_node<Elem> *list_node<Elem>::nil() { return new nil_node<Elem>(); }$/;"	f	class:list_node	typeref:typename:list_node<Elem> *	signature:()
list_node::nth	tree.h	/^    Elem nth(int n);$/;"	p	class:list_node	typeref:typename:Elem	access:public	signature:(int n)
list_node::nth	tree.h	/^template <class Elem> Elem list_node<Elem>::nth(int n)$/;"	f	class:list_node	typeref:typename:Elem	signature:(int n)
list_node::nth_length	tree.h	/^    virtual Elem nth_length(int n, int &len) = 0;$/;"	p	class:list_node	typeref:typename:Elem	access:public	signature:(int n,int & len)
list_node::single	tree.h	/^    static list_node<Elem> *single(Elem);$/;"	p	class:list_node	typeref:typename:list_node<Elem> *	access:public	signature:(Elem)
list_node::single	tree.h	/^template <class Elem> list_node<Elem> *list_node<Elem>::single(Elem e) { return new single_list_/;"	f	class:list_node	typeref:typename:list_node<Elem> *	signature:(Elem e)
list_node::~list_node	tree.h	/^    virtual ~list_node() { }$/;"	f	class:list_node	access:public	signature:()
list_print	list.h	/^void list_print(S &str, List<T> *l)$/;"	f	typeref:typename:void	signature:(S & str,List<T> * l)
lookup	stringtab.h	/^		Elem *lookup(int index);      \/\/ lookup an element using its index$/;"	p	class:StringTable	typeref:typename:Elem *	access:public	signature:(int index)
lookup	stringtab_functions.h	/^Elem *StringTable<Elem>::lookup(int ind)$/;"	f	class:StringTable	typeref:typename:Elem *	signature:(int ind)
lookup	symtab.h	/^	DAT * lookup(SYM s)$/;"	f	class:SymbolTable	typeref:typename:DAT *	access:public	signature:(SYM s)
lookup_string	stringtab.h	/^		Elem *lookup_string(char *s); \/\/ lookup an element using its string$/;"	p	class:StringTable	typeref:typename:Elem *	access:public	signature:(char * s)
lookup_string	stringtab_functions.h	/^Elem *StringTable<Elem>::lookup_string(char *s)$/;"	f	class:StringTable	typeref:typename:Elem *	signature:(char * s)
loop	cool-tree.cc	/^Expression loop(Expression pred, Expression body)$/;"	f	typeref:typename:Expression	signature:(Expression pred,Expression body)
loop	cool-tree.h	/^Expression loop(Expression, Expression);$/;"	p	typeref:typename:Expression	signature:(Expression,Expression)
loop_class	cool-tree.h	/^   loop_class(Expression a1, Expression a2) {$/;"	f	class:loop_class	access:public	signature:(Expression a1,Expression a2)
loop_class	cool-tree.h	/^class loop_class : public Expression_class {$/;"	c	inherits:Expression_class
loop_class::body	cool-tree.h	/^   Expression body;$/;"	m	class:loop_class	typeref:typename:Expression	access:protected
loop_class::code	cgen.cc	/^void loop_class::code(ostream &s) {$/;"	f	class:loop_class	typeref:typename:void	signature:(ostream & s)
loop_class::copy_Expression	cool-tree.cc	/^Expression loop_class::copy_Expression()$/;"	f	class:loop_class	typeref:typename:Expression	signature:()
loop_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:loop_class	typeref:typename:Expression	access:public	signature:()
loop_class::dump	cool-tree.cc	/^void loop_class::dump(ostream& stream, int n)$/;"	f	class:loop_class	typeref:typename:void	signature:(ostream & stream,int n)
loop_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:loop_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
loop_class::dump_with_types	dumptype.cc	/^void loop_class::dump_with_types(ostream& stream, int n)$/;"	f	class:loop_class	typeref:typename:void	signature:(ostream & stream,int n)
loop_class::loop_class	cool-tree.h	/^   loop_class(Expression a1, Expression a2) {$/;"	f	class:loop_class	access:public	signature:(Expression a1,Expression a2)
loop_class::pred	cool-tree.h	/^   Expression pred;$/;"	m	class:loop_class	typeref:typename:Expression	access:protected
lsource	Makefile	/^lsource: ${LSRC}$/;"	t
lt	cool-tree.cc	/^Expression lt(Expression e1, Expression e2)$/;"	f	typeref:typename:Expression	signature:(Expression e1,Expression e2)
lt	cool-tree.h	/^Expression lt(Expression, Expression);$/;"	p	typeref:typename:Expression	signature:(Expression,Expression)
lt_class	cool-tree.h	/^   lt_class(Expression a1, Expression a2) {$/;"	f	class:lt_class	access:public	signature:(Expression a1,Expression a2)
lt_class	cool-tree.h	/^class lt_class : public Expression_class {$/;"	c	inherits:Expression_class
lt_class::code	cgen.cc	/^void lt_class::code(ostream &s) {$/;"	f	class:lt_class	typeref:typename:void	signature:(ostream & s)
lt_class::copy_Expression	cool-tree.cc	/^Expression lt_class::copy_Expression()$/;"	f	class:lt_class	typeref:typename:Expression	signature:()
lt_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:lt_class	typeref:typename:Expression	access:public	signature:()
lt_class::dump	cool-tree.cc	/^void lt_class::dump(ostream& stream, int n)$/;"	f	class:lt_class	typeref:typename:void	signature:(ostream & stream,int n)
lt_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:lt_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
lt_class::dump_with_types	dumptype.cc	/^void lt_class::dump_with_types(ostream& stream, int n)$/;"	f	class:lt_class	typeref:typename:void	signature:(ostream & stream,int n)
lt_class::e1	cool-tree.h	/^   Expression e1;$/;"	m	class:lt_class	typeref:typename:Expression	access:protected
lt_class::e2	cool-tree.h	/^   Expression e2;$/;"	m	class:lt_class	typeref:typename:Expression	access:protected
lt_class::lt_class	cool-tree.h	/^   lt_class(Expression a1, Expression a2) {$/;"	f	class:lt_class	access:public	signature:(Expression a1,Expression a2)
main	cgen-phase.cc	/^int main(int argc, char *argv[]) {$/;"	f	typeref:typename:int	signature:(int argc,char * argv[])
main_meth	cgen.cc	/^	main_meth,$/;"	v	typeref:typename:Symbol
malloc	ast-parse.cc	/^void *malloc (YYSIZE_T); \/* INFRINGES ON USER NAME SPACE *\/$/;"	p	typeref:typename:void *	file:	signature:(YYSIZE_T)
method	cool-tree.cc	/^Feature method(Symbol name, Formals formals, Symbol return_type, Expression expr)$/;"	f	typeref:typename:Feature	signature:(Symbol name,Formals formals,Symbol return_type,Expression expr)
method	cool-tree.h	/^Feature method(Symbol, Formals, Symbol, Expression);$/;"	p	typeref:typename:Feature	signature:(Symbol,Formals,Symbol,Expression)
method_EXTRAS	cool-tree.handcode.h	/^#define method_EXTRAS	/;"	d
method_class	cool-tree.h	/^   method_class(Symbol a1, Formals a2, Symbol a3, Expression a4) {$/;"	f	class:method_class	access:public	signature:(Symbol a1,Formals a2,Symbol a3,Expression a4)
method_class	cool-tree.h	/^class method_class : public Feature_class {$/;"	c	inherits:Feature_class
method_class::code	cgen.cc	/^void method_class::code(ostream &s) {$/;"	f	class:method_class	typeref:typename:void	signature:(ostream & s)
method_class::copy_Feature	cool-tree.cc	/^Feature method_class::copy_Feature()$/;"	f	class:method_class	typeref:typename:Feature	signature:()
method_class::copy_Feature	cool-tree.h	/^   Feature copy_Feature();$/;"	p	class:method_class	typeref:typename:Feature	access:public	signature:()
method_class::dump	cool-tree.cc	/^void method_class::dump(ostream& stream, int n)$/;"	f	class:method_class	typeref:typename:void	signature:(ostream & stream,int n)
method_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:method_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
method_class::dump_with_types	dumptype.cc	/^void method_class::dump_with_types(ostream& stream, int n)$/;"	f	class:method_class	typeref:typename:void	signature:(ostream & stream,int n)
method_class::expr	cool-tree.h	/^   Expression expr;$/;"	m	class:method_class	typeref:typename:Expression	access:protected
method_class::formals	cool-tree.h	/^   Formals formals;$/;"	m	class:method_class	typeref:typename:Formals	access:protected
method_class::install_args	cgen.cc	/^void method_class::install_args() {$/;"	f	class:method_class	typeref:typename:void	signature:()
method_class::method_class	cool-tree.h	/^   method_class(Symbol a1, Formals a2, Symbol a3, Expression a4) {$/;"	f	class:method_class	access:public	signature:(Symbol a1,Formals a2,Symbol a3,Expression a4)
method_class::name	cool-tree.h	/^   Symbol name;$/;"	m	class:method_class	typeref:typename:Symbol	access:protected
method_class::return_type	cool-tree.h	/^   Symbol return_type;$/;"	m	class:method_class	typeref:typename:Symbol	access:protected
method_class::tmp_Num	cgen.cc	/^int method_class::tmp_Num() { return expr->tmp_Num(); }$/;"	f	class:method_class	typeref:typename:int	signature:()
method_index	cgen.h	/^		std::map<Symbol, int> method_index;$/;"	m	class:CgenNode	typeref:typename:std::map<Symbol,int>	access:public
min	stringtab_functions.h	/^#define min(/;"	d	signature:(a,b)
more	stringtab.h	/^		int more(int i);   \/\/ are there more indices?$/;"	p	class:StringTable	typeref:typename:int	access:public	signature:(int i)
more	stringtab_functions.h	/^int StringTable<Elem>::more(int i)$/;"	f	class:StringTable	typeref:typename:int	signature:(int i)
more	tree.h	/^    int more(int n)  { return (n < len()); }$/;"	f	class:list_node	typeref:typename:int	access:public	signature:(int n)
mul	cool-tree.cc	/^Expression mul(Expression e1, Expression e2)$/;"	f	typeref:typename:Expression	signature:(Expression e1,Expression e2)
mul	cool-tree.h	/^Expression mul(Expression, Expression);$/;"	p	typeref:typename:Expression	signature:(Expression,Expression)
mul_class	cool-tree.h	/^   mul_class(Expression a1, Expression a2) {$/;"	f	class:mul_class	access:public	signature:(Expression a1,Expression a2)
mul_class	cool-tree.h	/^class mul_class : public Expression_class {$/;"	c	inherits:Expression_class
mul_class::code	cgen.cc	/^void mul_class::code(ostream &s) {$/;"	f	class:mul_class	typeref:typename:void	signature:(ostream & s)
mul_class::copy_Expression	cool-tree.cc	/^Expression mul_class::copy_Expression()$/;"	f	class:mul_class	typeref:typename:Expression	signature:()
mul_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:mul_class	typeref:typename:Expression	access:public	signature:()
mul_class::dump	cool-tree.cc	/^void mul_class::dump(ostream& stream, int n)$/;"	f	class:mul_class	typeref:typename:void	signature:(ostream & stream,int n)
mul_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:mul_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
mul_class::dump_with_types	dumptype.cc	/^void mul_class::dump_with_types(ostream& stream, int n)$/;"	f	class:mul_class	typeref:typename:void	signature:(ostream & stream,int n)
mul_class::e1	cool-tree.h	/^   Expression e1;$/;"	m	class:mul_class	typeref:typename:Expression	access:protected
mul_class::e2	cool-tree.h	/^   Expression e2;$/;"	m	class:mul_class	typeref:typename:Expression	access:protected
mul_class::mul_class	cool-tree.h	/^   mul_class(Expression a1, Expression a2) {$/;"	f	class:mul_class	access:public	signature:(Expression a1,Expression a2)
name	cool-tree.h	/^   Symbol name;$/;"	m	class:assign_class	typeref:typename:Symbol	access:protected
name	cool-tree.h	/^   Symbol name;$/;"	m	class:attr_class	typeref:typename:Symbol	access:protected
name	cool-tree.h	/^   Symbol name;$/;"	m	class:branch_class	typeref:typename:Symbol	access:protected
name	cool-tree.h	/^   Symbol name;$/;"	m	class:class__class	typeref:typename:Symbol	access:protected
name	cool-tree.h	/^   Symbol name;$/;"	m	class:dispatch_class	typeref:typename:Symbol	access:protected
name	cool-tree.h	/^   Symbol name;$/;"	m	class:formal_class	typeref:typename:Symbol	access:protected
name	cool-tree.h	/^   Symbol name;$/;"	m	class:method_class	typeref:typename:Symbol	access:protected
name	cool-tree.h	/^   Symbol name;$/;"	m	class:object_class	typeref:typename:Symbol	access:protected
name	cool-tree.h	/^   Symbol name;$/;"	m	class:static_dispatch_class	typeref:typename:Symbol	access:protected
nds	cgen.h	/^		List<CgenNode> *nds;$/;"	m	class:CgenClassTable	typeref:typename:List<CgenNode> *	access:private
neg	cool-tree.cc	/^Expression neg(Expression e1)$/;"	f	typeref:typename:Expression	signature:(Expression e1)
neg	cool-tree.h	/^Expression neg(Expression);$/;"	p	typeref:typename:Expression	signature:(Expression)
neg_class	cool-tree.h	/^   neg_class(Expression a1) {$/;"	f	class:neg_class	access:public	signature:(Expression a1)
neg_class	cool-tree.h	/^class neg_class : public Expression_class {$/;"	c	inherits:Expression_class
neg_class::code	cgen.cc	/^void neg_class::code(ostream &s) {$/;"	f	class:neg_class	typeref:typename:void	signature:(ostream & s)
neg_class::copy_Expression	cool-tree.cc	/^Expression neg_class::copy_Expression()$/;"	f	class:neg_class	typeref:typename:Expression	signature:()
neg_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:neg_class	typeref:typename:Expression	access:public	signature:()
neg_class::dump	cool-tree.cc	/^void neg_class::dump(ostream& stream, int n)$/;"	f	class:neg_class	typeref:typename:void	signature:(ostream & stream,int n)
neg_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:neg_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
neg_class::dump_with_types	dumptype.cc	/^void neg_class::dump_with_types(ostream& stream, int n)$/;"	f	class:neg_class	typeref:typename:void	signature:(ostream & stream,int n)
neg_class::e1	cool-tree.h	/^   Expression e1;$/;"	m	class:neg_class	typeref:typename:Expression	access:protected
neg_class::neg_class	cool-tree.h	/^   neg_class(Expression a1) {$/;"	f	class:neg_class	access:public	signature:(Expression a1)
new_	cool-tree.cc	/^Expression new_(Symbol type_name)$/;"	f	typeref:typename:Expression	signature:(Symbol type_name)
new_	cool-tree.h	/^Expression new_(Symbol);$/;"	p	typeref:typename:Expression	signature:(Symbol)
new__class	cool-tree.h	/^   new__class(Symbol a1) {$/;"	f	class:new__class	access:public	signature:(Symbol a1)
new__class	cool-tree.h	/^class new__class : public Expression_class {$/;"	c	inherits:Expression_class
new__class::code	cgen.cc	/^void new__class::code(ostream &s) {$/;"	f	class:new__class	typeref:typename:void	signature:(ostream & s)
new__class::copy_Expression	cool-tree.cc	/^Expression new__class::copy_Expression()$/;"	f	class:new__class	typeref:typename:Expression	signature:()
new__class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:new__class	typeref:typename:Expression	access:public	signature:()
new__class::dump	cool-tree.cc	/^void new__class::dump(ostream& stream, int n)$/;"	f	class:new__class	typeref:typename:void	signature:(ostream & stream,int n)
new__class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:new__class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
new__class::dump_with_types	dumptype.cc	/^void new__class::dump_with_types(ostream& stream, int n)$/;"	f	class:new__class	typeref:typename:void	signature:(ostream & stream,int n)
new__class::new__class	cool-tree.h	/^   new__class(Symbol a1) {$/;"	f	class:new__class	access:public	signature:(Symbol a1)
new__class::type_name	cool-tree.h	/^   Symbol type_name;$/;"	m	class:new__class	typeref:typename:Symbol	access:protected
new_size	ast-lex.cc	/^				int new_size = b->yy_buf_size * 2;$/;"	v	typeref:typename:int
new_size	ast-lex.cc	/^		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);$/;"	v	typeref:typename:yy_size_t
next	stringtab.h	/^		int next(int i);   \/\/ next index$/;"	p	class:StringTable	typeref:typename:int	access:public	signature:(int i)
next	stringtab_functions.h	/^int StringTable<Elem>::next(int i)$/;"	f	class:StringTable	typeref:typename:int	signature:(int i)
next	tree.h	/^    int next(int n)  { return n + 1; }$/;"	f	class:list_node	typeref:typename:int	access:public	signature:(int n)
nil	tree.h	/^    static list_node<Elem> *nil();$/;"	p	class:list_node	typeref:typename:list_node<Elem> *	access:public	signature:()
nil	tree.h	/^template <class Elem> list_node<Elem> *list_node<Elem>::nil() { return new nil_node<Elem>(); }$/;"	f	class:list_node	typeref:typename:list_node<Elem> *	signature:()
nil_Cases	cool-tree.cc	/^Cases nil_Cases()$/;"	f	typeref:typename:Cases	signature:()
nil_Cases	cool-tree.h	/^Cases nil_Cases();$/;"	p	typeref:typename:Cases	signature:()
nil_Classes	cool-tree.cc	/^Classes nil_Classes()$/;"	f	typeref:typename:Classes	signature:()
nil_Classes	cool-tree.h	/^Classes nil_Classes();$/;"	p	typeref:typename:Classes	signature:()
nil_Expressions	cool-tree.cc	/^Expressions nil_Expressions()$/;"	f	typeref:typename:Expressions	signature:()
nil_Expressions	cool-tree.h	/^Expressions nil_Expressions();$/;"	p	typeref:typename:Expressions	signature:()
nil_Features	cool-tree.cc	/^Features nil_Features()$/;"	f	typeref:typename:Features	signature:()
nil_Features	cool-tree.h	/^Features nil_Features();$/;"	p	typeref:typename:Features	signature:()
nil_Formals	cool-tree.cc	/^Formals nil_Formals()$/;"	f	typeref:typename:Formals	signature:()
nil_Formals	cool-tree.h	/^Formals nil_Formals();$/;"	p	typeref:typename:Formals	signature:()
nil_node	tree.h	/^template <class Elem> class nil_node : public list_node<Elem> {$/;"	c	inherits:list_node<Elem>
nil_node::copy_list	tree.h	/^    list_node<Elem> *copy_list();$/;"	p	class:nil_node	typeref:typename:list_node<Elem> *	access:public	signature:()
nil_node::copy_list	tree.h	/^template <class Elem> list_node<Elem> *nil_node<Elem>::copy_list()$/;"	f	class:nil_node	typeref:typename:list_node<Elem> *	signature:()
nil_node::dump	tree.h	/^    void dump(ostream& stream, int n);$/;"	p	class:nil_node	typeref:typename:void	access:public	signature:(ostream & stream,int n)
nil_node::dump	tree.h	/^template <class Elem> void nil_node<Elem>::dump(ostream& stream, int n)$/;"	f	class:nil_node	typeref:typename:void	signature:(ostream & stream,int n)
nil_node::len	tree.h	/^    int len();$/;"	p	class:nil_node	typeref:typename:int	access:public	signature:()
nil_node::len	tree.h	/^template <class Elem> int nil_node<Elem>::len()$/;"	f	class:nil_node	typeref:typename:int	signature:()
nil_node::nth_length	tree.h	/^    Elem nth_length(int n, int &len);$/;"	p	class:nil_node	typeref:typename:Elem	access:public	signature:(int n,int & len)
nil_node::nth_length	tree.h	/^template <class Elem> Elem nil_node<Elem>::nth_length(int, int &len)$/;"	f	class:nil_node	typeref:typename:Elem	signature:(int,int & len)
no_expr	cool-tree.cc	/^Expression no_expr()$/;"	f	typeref:typename:Expression	signature:()
no_expr	cool-tree.h	/^Expression no_expr();$/;"	p	typeref:typename:Expression	signature:()
no_expr_EXTRAS	cool-tree.handcode.h	/^#define no_expr_EXTRAS	/;"	d
no_expr_class	cool-tree.h	/^   no_expr_class() {$/;"	f	class:no_expr_class	access:public	signature:()
no_expr_class	cool-tree.h	/^class no_expr_class : public Expression_class {$/;"	c	inherits:Expression_class
no_expr_class::code	cgen.cc	/^void no_expr_class::code(ostream &s) {$/;"	f	class:no_expr_class	typeref:typename:void	signature:(ostream & s)
no_expr_class::copy_Expression	cool-tree.cc	/^Expression no_expr_class::copy_Expression()$/;"	f	class:no_expr_class	typeref:typename:Expression	signature:()
no_expr_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:no_expr_class	typeref:typename:Expression	access:public	signature:()
no_expr_class::dump	cool-tree.cc	/^void no_expr_class::dump(ostream& stream, int n)$/;"	f	class:no_expr_class	typeref:typename:void	signature:(ostream & stream,int n)
no_expr_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:no_expr_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
no_expr_class::dump_with_types	dumptype.cc	/^void no_expr_class::dump_with_types(ostream& stream, int n)$/;"	f	class:no_expr_class	typeref:typename:void	signature:(ostream & stream,int n)
no_expr_class::no_expr_class	cool-tree.h	/^   no_expr_class() {$/;"	f	class:no_expr_class	access:public	signature:()
node_lineno	tree.cc	/^int node_lineno = 1;$/;"	v	typeref:typename:int
nodesize	cgen.cc	/^int label_num = 0, nodesize = 0;$/;"	v	typeref:typename:int
nth	tree.h	/^    Elem nth(int n);$/;"	p	class:append_node	typeref:typename:Elem	access:public	signature:(int n)
nth	tree.h	/^    Elem nth(int n);$/;"	p	class:list_node	typeref:typename:Elem	access:public	signature:(int n)
nth	tree.h	/^template <class Elem> Elem append_node<Elem>::nth(int n)$/;"	f	class:append_node	typeref:typename:Elem	signature:(int n)
nth	tree.h	/^template <class Elem> Elem list_node<Elem>::nth(int n)$/;"	f	class:list_node	typeref:typename:Elem	signature:(int n)
nth_length	tree.h	/^    Elem nth_length(int n, int &len);$/;"	p	class:append_node	typeref:typename:Elem	access:public	signature:(int n,int & len)
nth_length	tree.h	/^    Elem nth_length(int n, int &len);$/;"	p	class:nil_node	typeref:typename:Elem	access:public	signature:(int n,int & len)
nth_length	tree.h	/^    Elem nth_length(int n, int &len);$/;"	p	class:single_list_node	typeref:typename:Elem	access:public	signature:(int n,int & len)
nth_length	tree.h	/^    virtual Elem nth_length(int n, int &len) = 0;$/;"	p	class:list_node	typeref:typename:Elem	access:public	signature:(int n,int & len)
nth_length	tree.h	/^template <class Elem> Elem append_node<Elem>::nth_length(int n, int &len)$/;"	f	class:append_node	typeref:typename:Elem	signature:(int n,int & len)
nth_length	tree.h	/^template <class Elem> Elem nil_node<Elem>::nth_length(int, int &len)$/;"	f	class:nil_node	typeref:typename:Elem	signature:(int,int & len)
nth_length	tree.h	/^template <class Elem> Elem single_list_node<Elem>::nth_length(int n, int &len)$/;"	f	class:single_list_node	typeref:typename:Elem	signature:(int n,int & len)
num_to_read	ast-lex.cc	/^			int num_to_read =$/;"	v	typeref:typename:int
number_to_move	ast-lex.cc	/^	register int number_to_move, i;$/;"	v	typeref:typename:register int
object	cool-tree.cc	/^Expression object(Symbol name)$/;"	f	typeref:typename:Expression	signature:(Symbol name)
object	cool-tree.h	/^Expression object(Symbol);$/;"	p	typeref:typename:Expression	signature:(Symbol)
object_class	cool-tree.h	/^   object_class(Symbol a1) {$/;"	f	class:object_class	access:public	signature:(Symbol a1)
object_class	cool-tree.h	/^class object_class : public Expression_class {$/;"	c	inherits:Expression_class
object_class::code	cgen.cc	/^void object_class::code(ostream &s) {$/;"	f	class:object_class	typeref:typename:void	signature:(ostream & s)
object_class::copy_Expression	cool-tree.cc	/^Expression object_class::copy_Expression()$/;"	f	class:object_class	typeref:typename:Expression	signature:()
object_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:object_class	typeref:typename:Expression	access:public	signature:()
object_class::dump	cool-tree.cc	/^void object_class::dump(ostream& stream, int n)$/;"	f	class:object_class	typeref:typename:void	signature:(ostream & stream,int n)
object_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:object_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
object_class::dump_with_types	dumptype.cc	/^void object_class::dump_with_types(ostream& stream, int n)$/;"	f	class:object_class	typeref:typename:void	signature:(ostream & stream,int n)
object_class::name	cool-tree.h	/^   Symbol name;$/;"	m	class:object_class	typeref:typename:Symbol	access:protected
object_class::object_class	cool-tree.h	/^   object_class(Symbol a1) {$/;"	f	class:object_class	access:public	signature:(Symbol a1)
omerrs	ast-parse.cc	/^int omerrs = 0;               \/* number of errors in lexing and parsing *\/$/;"	v	typeref:typename:int
operator <<	stringtab.cc	/^ostream& operator<<(ostream& s, Symbol sym)$/;"	f	typeref:typename:ostream &	signature:(ostream & s,Symbol sym)
operator <<	stringtab.cc	/^ostream& operator<<(ostream& s, const Entry& sym) $/;"	f	typeref:typename:ostream &	signature:(ostream & s,const Entry & sym)
operator <<	stringtab.h	/^extern ostream& operator<<(ostream& s, Symbol sym);$/;"	p	typeref:typename:ostream &	signature:(ostream & s,Symbol sym)
operator <<	stringtab.h	/^extern ostream& operator<<(ostream& s, const Entry& sym);$/;"	p	typeref:typename:ostream &	signature:(ostream & s,const Entry & sym)
operator =	symtab.h	/^	SymbolTable &operator =(const SymbolTable &s) { tbl = s.tbl; return *this; }$/;"	f	class:SymbolTable	typeref:typename:SymbolTable &	access:public	signature:(const SymbolTable & s)
ostream	.vscode/settings.json	/^        "ostream": "cpp"$/;"	s	object:files.associations
out_filename	handle_flags.cc	/^       char *out_filename;      \/\/ file name for generated code$/;"	v	typeref:typename:char *
out_int	cgen.cc	/^	out_int,$/;"	v	typeref:typename:Symbol
out_string	cgen.cc	/^	out_string,$/;"	v	typeref:typename:Symbol
pad	stringtab.cc	/^extern char *pad(int n);$/;"	p	typeref:typename:char *	file:	signature:(int n)
pad	tree.h	/^char *pad(int n);$/;"	p	typeref:typename:char *	signature:(int n)
pad	utilities.cc	/^char *pad(int n) {$/;"	f	typeref:typename:char *	signature:(int n)
pad	utilities.h	/^extern char *pad(int);$/;"	p	typeref:typename:char *	signature:(int)
padding	utilities.cc	/^static char *padding = "                                                                        /;"	v	typeref:typename:char *	file:
parent	cool-tree.h	/^   Symbol parent;$/;"	m	class:class__class	typeref:typename:Symbol	access:protected
parentnd	cgen.h	/^		CgenNodeP parentnd;                        \/\/ Parent of class$/;"	m	class:CgenNode	typeref:typename:CgenNodeP	access:private
parse_results	ast-parse.cc	/^Classes parse_results;        \/* for use in parsing multiple files *\/$/;"	v	typeref:typename:Classes
plus	cool-tree.cc	/^Expression plus(Expression e1, Expression e2)$/;"	f	typeref:typename:Expression	signature:(Expression e1,Expression e2)
plus	cool-tree.h	/^Expression plus(Expression, Expression);$/;"	p	typeref:typename:Expression	signature:(Expression,Expression)
plus_class	cool-tree.h	/^   plus_class(Expression a1, Expression a2) {$/;"	f	class:plus_class	access:public	signature:(Expression a1,Expression a2)
plus_class	cool-tree.h	/^class plus_class : public Expression_class {$/;"	c	inherits:Expression_class
plus_class::code	cgen.cc	/^void plus_class::code(ostream &s) {$/;"	f	class:plus_class	typeref:typename:void	signature:(ostream & s)
plus_class::copy_Expression	cool-tree.cc	/^Expression plus_class::copy_Expression()$/;"	f	class:plus_class	typeref:typename:Expression	signature:()
plus_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:plus_class	typeref:typename:Expression	access:public	signature:()
plus_class::dump	cool-tree.cc	/^void plus_class::dump(ostream& stream, int n)$/;"	f	class:plus_class	typeref:typename:void	signature:(ostream & stream,int n)
plus_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:plus_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
plus_class::dump_with_types	dumptype.cc	/^void plus_class::dump_with_types(ostream& stream, int n)$/;"	f	class:plus_class	typeref:typename:void	signature:(ostream & stream,int n)
plus_class::e1	cool-tree.h	/^   Expression e1;$/;"	m	class:plus_class	typeref:typename:Expression	access:protected
plus_class::e2	cool-tree.h	/^   Expression e2;$/;"	m	class:plus_class	typeref:typename:Expression	access:protected
plus_class::plus_class	cool-tree.h	/^   plus_class(Expression a1, Expression a2) {$/;"	f	class:plus_class	access:public	signature:(Expression a1,Expression a2)
pred	cool-tree.h	/^   Expression pred;$/;"	m	class:cond_class	typeref:typename:Expression	access:protected
pred	cool-tree.h	/^   Expression pred;$/;"	m	class:loop_class	typeref:typename:Expression	access:protected
prim_slot	cgen.cc	/^	prim_slot,$/;"	v	typeref:typename:Symbol
print	stringtab.cc	/^ostream& Entry::print(ostream& s) const$/;"	f	class:Entry	typeref:typename:ostream &	signature:(ostream & s) const
print	stringtab.h	/^		ostream& print(ostream& s) const;$/;"	p	class:Entry	typeref:typename:ostream &	access:public	signature:(ostream & s) const
print	stringtab.h	/^		void print();  \/\/ print the entire table; for debugging$/;"	p	class:StringTable	typeref:typename:void	access:public	signature:()
print	stringtab_functions.h	/^void StringTable<Elem>::print()$/;"	f	class:StringTable	typeref:typename:void	signature:()
print_cool_token	utilities.cc	/^void print_cool_token(int tok)$/;"	f	typeref:typename:void	signature:(int tok)
print_cool_token	utilities.h	/^extern void print_cool_token(int tok);$/;"	p	typeref:typename:void	signature:(int tok)
print_escaped_string	utilities.cc	/^void print_escaped_string(ostream& str, const char *s)$/;"	f	typeref:typename:void	signature:(ostream & str,const char * s)
print_escaped_string	utilities.h	/^extern void print_escaped_string(ostream& str, const char *s);$/;"	p	typeref:typename:void	signature:(ostream & str,const char * s)
probe	symtab.h	/^	DAT *probe(SYM s)$/;"	f	class:SymbolTable	typeref:typename:DAT *	access:public	signature:(SYM s)
program	ast-parse.cc	/^  Program program;$/;"	m	union:YYSTYPE	typeref:typename:Program	file:	access:public
program	ast-parse.h	/^  Program program;$/;"	m	union:YYSTYPE	typeref:typename:Program	access:public
program	cool-parse.h	/^  Program program;$/;"	m	union:YYSTYPE	typeref:typename:Program	access:public
program	cool-tree.cc	/^Program program(Classes classes)$/;"	f	typeref:typename:Program	signature:(Classes classes)
program	cool-tree.h	/^Program program(Classes);$/;"	p	typeref:typename:Program	signature:(Classes)
program_EXTRAS	cool-tree.handcode.h	/^#define program_EXTRAS /;"	d
program_class	cool-tree.h	/^   program_class(Classes a1) {$/;"	f	class:program_class	access:public	signature:(Classes a1)
program_class	cool-tree.h	/^class program_class : public Program_class {$/;"	c	inherits:Program_class
program_class::cgen	cgen.cc	/^void program_class::cgen(ostream &os) $/;"	f	class:program_class	typeref:typename:void	signature:(ostream & os)
program_class::classes	cool-tree.h	/^   Classes classes;$/;"	m	class:program_class	typeref:typename:Classes	access:protected
program_class::copy_Program	cool-tree.cc	/^Program program_class::copy_Program()$/;"	f	class:program_class	typeref:typename:Program	signature:()
program_class::copy_Program	cool-tree.h	/^   Program copy_Program();$/;"	p	class:program_class	typeref:typename:Program	access:public	signature:()
program_class::dump	cool-tree.cc	/^void program_class::dump(ostream& stream, int n)$/;"	f	class:program_class	typeref:typename:void	signature:(ostream & stream,int n)
program_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:program_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
program_class::dump_with_types	dumptype.cc	/^void program_class::dump_with_types(ostream& stream, int n)$/;"	f	class:program_class	typeref:typename:void	signature:(ostream & stream,int n)
program_class::program_class	cool-tree.h	/^   program_class(Classes a1) {$/;"	f	class:program_class	access:public	signature:(Classes a1)
rest	tree.h	/^    list_node<Elem> *some, *rest;$/;"	m	class:append_node	typeref:typename:list_node<Elem> *	access:private
ret_val	ast-lex.cc	/^	int ret_val;$/;"	v	typeref:typename:int
return_type	cool-tree.h	/^   Symbol return_type;$/;"	m	class:method_class	typeref:typename:Symbol	access:protected
root	cgen.cc	/^CgenNodeP CgenClassTable::root()$/;"	f	class:CgenClassTable	typeref:typename:CgenNodeP	signature:()
root	cgen.h	/^		CgenNodeP root();$/;"	p	class:CgenClassTable	typeref:typename:CgenNodeP	access:public	signature:()
self	cgen.cc	/^	self,$/;"	v	typeref:typename:Symbol
semant_debug	handle_flags.cc	/^       int semant_debug;        \/\/ for semantic analysis$/;"	v	typeref:typename:int
set	tree.cc	/^tree_node *tree_node::set(tree_node *t) {$/;"	f	class:tree_node	typeref:typename:tree_node *	signature:(tree_node * t)
set	tree.h	/^    tree_node *set(tree_node *);$/;"	p	class:tree_node	typeref:typename:tree_node *	access:public	signature:(tree_node *)
set_parentnd	cgen.cc	/^void CgenNode::set_parentnd(CgenNodeP p)$/;"	f	class:CgenNode	typeref:typename:void	signature:(CgenNodeP p)
set_parentnd	cgen.h	/^		void set_parentnd(CgenNodeP p);$/;"	p	class:CgenNode	typeref:typename:void	access:public	signature:(CgenNodeP p)
set_relations	cgen.cc	/^void CgenClassTable::set_relations(CgenNodeP nd)$/;"	f	class:CgenClassTable	typeref:typename:void	signature:(CgenNodeP nd)
set_relations	cgen.h	/^		void set_relations(CgenNodeP nd);$/;"	p	class:CgenClassTable	typeref:typename:void	access:private	signature:(CgenNodeP nd)
single	tree.h	/^    static list_node<Elem> *single(Elem);$/;"	p	class:list_node	typeref:typename:list_node<Elem> *	access:public	signature:(Elem)
single	tree.h	/^template <class Elem> list_node<Elem> *list_node<Elem>::single(Elem e) { return new single_list_/;"	f	class:list_node	typeref:typename:list_node<Elem> *	signature:(Elem e)
single_Cases	cool-tree.cc	/^Cases single_Cases(Case e)$/;"	f	typeref:typename:Cases	signature:(Case e)
single_Cases	cool-tree.h	/^Cases single_Cases(Case);$/;"	p	typeref:typename:Cases	signature:(Case)
single_Classes	cool-tree.cc	/^Classes single_Classes(Class_ e)$/;"	f	typeref:typename:Classes	signature:(Class_ e)
single_Classes	cool-tree.h	/^Classes single_Classes(Class_);$/;"	p	typeref:typename:Classes	signature:(Class_)
single_Expressions	cool-tree.cc	/^Expressions single_Expressions(Expression e)$/;"	f	typeref:typename:Expressions	signature:(Expression e)
single_Expressions	cool-tree.h	/^Expressions single_Expressions(Expression);$/;"	p	typeref:typename:Expressions	signature:(Expression)
single_Features	cool-tree.cc	/^Features single_Features(Feature e)$/;"	f	typeref:typename:Features	signature:(Feature e)
single_Features	cool-tree.h	/^Features single_Features(Feature);$/;"	p	typeref:typename:Features	signature:(Feature)
single_Formals	cool-tree.cc	/^Formals single_Formals(Formal e)$/;"	f	typeref:typename:Formals	signature:(Formal e)
single_Formals	cool-tree.h	/^Formals single_Formals(Formal);$/;"	p	typeref:typename:Formals	signature:(Formal)
single_list_node	tree.h	/^    single_list_node(Elem t) {$/;"	f	class:single_list_node	access:public	signature:(Elem t)
single_list_node	tree.h	/^template <class Elem> class single_list_node : public list_node<Elem> {$/;"	c	inherits:list_node<Elem>
single_list_node::copy_list	tree.h	/^    list_node<Elem> *copy_list();$/;"	p	class:single_list_node	typeref:typename:list_node<Elem> *	access:public	signature:()
single_list_node::copy_list	tree.h	/^template <class Elem> list_node<Elem> *single_list_node<Elem>::copy_list()$/;"	f	class:single_list_node	typeref:typename:list_node<Elem> *	signature:()
single_list_node::dump	tree.h	/^    void dump(ostream& stream, int n);$/;"	p	class:single_list_node	typeref:typename:void	access:public	signature:(ostream & stream,int n)
single_list_node::dump	tree.h	/^template <class Elem> void single_list_node<Elem>::dump(ostream& stream, int n)$/;"	f	class:single_list_node	typeref:typename:void	signature:(ostream & stream,int n)
single_list_node::elem	tree.h	/^    Elem elem;$/;"	m	class:single_list_node	typeref:typename:Elem	access:private
single_list_node::len	tree.h	/^    int len();$/;"	p	class:single_list_node	typeref:typename:int	access:public	signature:()
single_list_node::len	tree.h	/^template <class Elem> int single_list_node<Elem>::len()$/;"	f	class:single_list_node	typeref:typename:int	signature:()
single_list_node::nth_length	tree.h	/^    Elem nth_length(int n, int &len);$/;"	p	class:single_list_node	typeref:typename:Elem	access:public	signature:(int n,int & len)
single_list_node::nth_length	tree.h	/^template <class Elem> Elem single_list_node<Elem>::nth_length(int n, int &len)$/;"	f	class:single_list_node	typeref:typename:Elem	signature:(int n,int & len)
single_list_node::single_list_node	tree.h	/^    single_list_node(Elem t) {$/;"	f	class:single_list_node	access:public	signature:(Elem t)
some	tree.h	/^    list_node<Elem> *some, *rest;$/;"	m	class:append_node	typeref:typename:list_node<Elem> *	access:private
source	Makefile	/^source: ${SRC} ${TSRC} ${LIBS} lsource$/;"	t
source	ast-lex.cc	/^	register char *source = (yytext_ptr);$/;"	v	typeref:typename:register char *
static_dispatch	cool-tree.cc	/^Expression static_dispatch(Expression expr, Symbol type_name, Symbol name, Expressions actual)$/;"	f	typeref:typename:Expression	signature:(Expression expr,Symbol type_name,Symbol name,Expressions actual)
static_dispatch	cool-tree.h	/^Expression static_dispatch(Expression, Symbol, Symbol, Expressions);$/;"	p	typeref:typename:Expression	signature:(Expression,Symbol,Symbol,Expressions)
static_dispatch_class	cool-tree.h	/^   static_dispatch_class(Expression a1, Symbol a2, Symbol a3, Expressions a4) {$/;"	f	class:static_dispatch_class	access:public	signature:(Expression a1,Symbol a2,Symbol a3,Expressions a4)
static_dispatch_class	cool-tree.h	/^class static_dispatch_class : public Expression_class {$/;"	c	inherits:Expression_class
static_dispatch_class::actual	cool-tree.h	/^   Expressions actual;$/;"	m	class:static_dispatch_class	typeref:typename:Expressions	access:protected
static_dispatch_class::code	cgen.cc	/^void static_dispatch_class::code(ostream &s) {$/;"	f	class:static_dispatch_class	typeref:typename:void	signature:(ostream & s)
static_dispatch_class::copy_Expression	cool-tree.cc	/^Expression static_dispatch_class::copy_Expression()$/;"	f	class:static_dispatch_class	typeref:typename:Expression	signature:()
static_dispatch_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:static_dispatch_class	typeref:typename:Expression	access:public	signature:()
static_dispatch_class::dump	cool-tree.cc	/^void static_dispatch_class::dump(ostream& stream, int n)$/;"	f	class:static_dispatch_class	typeref:typename:void	signature:(ostream & stream,int n)
static_dispatch_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:static_dispatch_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
static_dispatch_class::dump_with_types	dumptype.cc	/^void static_dispatch_class::dump_with_types(ostream& stream, int n)$/;"	f	class:static_dispatch_class	typeref:typename:void	signature:(ostream & stream,int n)
static_dispatch_class::expr	cool-tree.h	/^   Expression expr;$/;"	m	class:static_dispatch_class	typeref:typename:Expression	access:protected
static_dispatch_class::name	cool-tree.h	/^   Symbol name;$/;"	m	class:static_dispatch_class	typeref:typename:Symbol	access:protected
static_dispatch_class::static_dispatch_class	cool-tree.h	/^   static_dispatch_class(Expression a1, Symbol a2, Symbol a3, Expressions a4) {$/;"	f	class:static_dispatch_class	access:public	signature:(Expression a1,Symbol a2,Symbol a3,Expressions a4)
static_dispatch_class::type_name	cool-tree.h	/^   Symbol type_name;$/;"	m	class:static_dispatch_class	typeref:typename:Symbol	access:protected
str	cgen.h	/^		ostream& str;$/;"	m	class:CgenClassTable	typeref:typename:ostream &	access:private
str	stringtab.h	/^		char *str;     \/\/ the string$/;"	m	class:Entry	typeref:typename:char *	access:protected
str_field	cgen.cc	/^	str_field,$/;"	v	typeref:typename:Symbol
strdup	utilities.cc	/^char *strdup(const char *s)$/;"	f	typeref:typename:char *	signature:(const char * s)
string_buf	ast-lex.cc	/^char string_buf[MAX_STR_CONST]; \/* to assemble string constants *\/$/;"	v	typeref:typename:char[]
string_buf_ptr	ast-lex.cc	/^char *string_buf_ptr;$/;"	v	typeref:typename:char *
string_const	cool-tree.cc	/^Expression string_const(Symbol token)$/;"	f	typeref:typename:Expression	signature:(Symbol token)
string_const	cool-tree.h	/^Expression string_const(Symbol);$/;"	p	typeref:typename:Expression	signature:(Symbol)
string_const_class	cool-tree.h	/^   string_const_class(Symbol a1) {$/;"	f	class:string_const_class	access:public	signature:(Symbol a1)
string_const_class	cool-tree.h	/^class string_const_class : public Expression_class {$/;"	c	inherits:Expression_class
string_const_class::code	cgen.cc	/^void string_const_class::code(ostream& s)$/;"	f	class:string_const_class	typeref:typename:void	signature:(ostream & s)
string_const_class::copy_Expression	cool-tree.cc	/^Expression string_const_class::copy_Expression()$/;"	f	class:string_const_class	typeref:typename:Expression	signature:()
string_const_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:string_const_class	typeref:typename:Expression	access:public	signature:()
string_const_class::dump	cool-tree.cc	/^void string_const_class::dump(ostream& stream, int n)$/;"	f	class:string_const_class	typeref:typename:void	signature:(ostream & stream,int n)
string_const_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:string_const_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
string_const_class::dump_with_types	dumptype.cc	/^void string_const_class::dump_with_types(ostream& stream, int n)$/;"	f	class:string_const_class	typeref:typename:void	signature:(ostream & stream,int n)
string_const_class::string_const_class	cool-tree.h	/^   string_const_class(Symbol a1) {$/;"	f	class:string_const_class	access:public	signature:(Symbol a1)
string_const_class::token	cool-tree.h	/^   Symbol token;$/;"	m	class:string_const_class	typeref:typename:Symbol	access:protected
stringclasstag	cgen.h	/^		int stringclasstag;$/;"	m	class:CgenClassTable	typeref:typename:int	access:private
stringtable	stringtab.cc	/^StrTable stringtable;$/;"	v	typeref:typename:StrTable
sub	cool-tree.cc	/^Expression sub(Expression e1, Expression e2)$/;"	f	typeref:typename:Expression	signature:(Expression e1,Expression e2)
sub	cool-tree.h	/^Expression sub(Expression, Expression);$/;"	p	typeref:typename:Expression	signature:(Expression,Expression)
sub_class	cool-tree.h	/^   sub_class(Expression a1, Expression a2) {$/;"	f	class:sub_class	access:public	signature:(Expression a1,Expression a2)
sub_class	cool-tree.h	/^class sub_class : public Expression_class {$/;"	c	inherits:Expression_class
sub_class::code	cgen.cc	/^void sub_class::code(ostream &s) {$/;"	f	class:sub_class	typeref:typename:void	signature:(ostream & s)
sub_class::copy_Expression	cool-tree.cc	/^Expression sub_class::copy_Expression()$/;"	f	class:sub_class	typeref:typename:Expression	signature:()
sub_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:sub_class	typeref:typename:Expression	access:public	signature:()
sub_class::dump	cool-tree.cc	/^void sub_class::dump(ostream& stream, int n)$/;"	f	class:sub_class	typeref:typename:void	signature:(ostream & stream,int n)
sub_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:sub_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
sub_class::dump_with_types	dumptype.cc	/^void sub_class::dump_with_types(ostream& stream, int n)$/;"	f	class:sub_class	typeref:typename:void	signature:(ostream & stream,int n)
sub_class::e1	cool-tree.h	/^   Expression e1;$/;"	m	class:sub_class	typeref:typename:Expression	access:protected
sub_class::e2	cool-tree.h	/^   Expression e2;$/;"	m	class:sub_class	typeref:typename:Expression	access:protected
sub_class::sub_class	cool-tree.h	/^   sub_class(Expression a1, Expression a2) {$/;"	f	class:sub_class	access:public	signature:(Expression a1,Expression a2)
substr	cgen.cc	/^	substr,$/;"	v	typeref:typename:Symbol
symbol	ast-parse.cc	/^  Symbol symbol;$/;"	m	union:YYSTYPE	typeref:typename:Symbol	file:	access:public
symbol	ast-parse.h	/^  Symbol symbol;$/;"	m	union:YYSTYPE	typeref:typename:Symbol	access:public
symbol	cool-parse.h	/^  Symbol symbol;$/;"	m	union:YYSTYPE	typeref:typename:Symbol	access:public
tag	cgen.h	/^		int tag;$/;"	m	class:CgenNode	typeref:typename:int	access:public
tail	list.h	/^  List<T>* tail;$/;"	m	class:List	typeref:typename:List<T> *	access:private
tbl	stringtab.h	/^		List<Elem> *tbl;   \/\/ a string table is a list$/;"	m	class:StringTable	typeref:typename:List<Elem> *	access:protected
tbl	symtab.h	/^	ScopeList  *tbl;$/;"	m	class:SymbolTable	typeref:typename:ScopeList *	access:private
temp_size	cgen.cc	/^int temp_size, used_temp = 0;$/;"	v	typeref:typename:int
then_exp	cool-tree.h	/^   Expression then_exp;$/;"	m	class:cond_class	typeref:typename:Expression	access:protected
tl	list.h	/^  List<T>* tl() const { return tail; }$/;"	f	class:List	typeref:typename:List<T> *	access:public	signature:() const
tmp_Num	cgen.cc	/^int assign_class::tmp_Num() { return expr->tmp_Num(); }$/;"	f	class:assign_class	typeref:typename:int	signature:()
tmp_Num	cgen.cc	/^int attr_class::tmp_Num() { return init->tmp_Num(); }$/;"	f	class:attr_class	typeref:typename:int	signature:()
tmp_Num	cgen.cc	/^int method_class::tmp_Num() { return expr->tmp_Num(); }$/;"	f	class:method_class	typeref:typename:int	signature:()
token	cool-tree.h	/^   Symbol token;$/;"	m	class:int_const_class	typeref:typename:Symbol	access:protected
token	cool-tree.h	/^   Symbol token;$/;"	m	class:string_const_class	typeref:typename:Symbol	access:protected
tree_node	tree.cc	/^tree_node::tree_node()$/;"	f	class:tree_node	signature:()
tree_node	tree.h	/^    tree_node();$/;"	p	class:tree_node	access:public	signature:()
tree_node	tree.h	/^class tree_node {$/;"	c
tree_node::copy	tree.h	/^    virtual tree_node *copy() = 0;$/;"	p	class:tree_node	typeref:typename:tree_node *	access:public	signature:()
tree_node::dump	tree.h	/^    virtual void dump(ostream& stream, int n) = 0;$/;"	p	class:tree_node	typeref:typename:void	access:public	signature:(ostream & stream,int n)
tree_node::get_line_number	tree.cc	/^int tree_node::get_line_number()$/;"	f	class:tree_node	typeref:typename:int	signature:()
tree_node::get_line_number	tree.h	/^    int get_line_number();$/;"	p	class:tree_node	typeref:typename:int	access:public	signature:()
tree_node::line_number	tree.h	/^    int line_number;            \/\/ stash the line number when node is made$/;"	m	class:tree_node	typeref:typename:int	access:protected
tree_node::set	tree.cc	/^tree_node *tree_node::set(tree_node *t) {$/;"	f	class:tree_node	typeref:typename:tree_node *	signature:(tree_node * t)
tree_node::set	tree.h	/^    tree_node *set(tree_node *);$/;"	p	class:tree_node	typeref:typename:tree_node *	access:public	signature:(tree_node *)
tree_node::tree_node	tree.cc	/^tree_node::tree_node()$/;"	f	class:tree_node	signature:()
tree_node::tree_node	tree.h	/^    tree_node();$/;"	p	class:tree_node	access:public	signature:()
tree_node::~tree_node	tree.h	/^    virtual ~tree_node() { }$/;"	f	class:tree_node	access:public	signature:()
truebool	cgen.cc	/^BoolConst truebool(TRUE);$/;"	p	typeref:typename:BoolConst	file:	signature:(TRUE)
typcase	cool-tree.cc	/^Expression typcase(Expression expr, Cases cases)$/;"	f	typeref:typename:Expression	signature:(Expression expr,Cases cases)
typcase	cool-tree.h	/^Expression typcase(Expression, Cases);$/;"	p	typeref:typename:Expression	signature:(Expression,Cases)
typcase_class	cool-tree.h	/^   typcase_class(Expression a1, Cases a2) {$/;"	f	class:typcase_class	access:public	signature:(Expression a1,Cases a2)
typcase_class	cool-tree.h	/^class typcase_class : public Expression_class {$/;"	c	inherits:Expression_class
typcase_class::cases	cool-tree.h	/^   Cases cases;$/;"	m	class:typcase_class	typeref:typename:Cases	access:protected
typcase_class::code	cgen.cc	/^void typcase_class::code(ostream &s) {$/;"	f	class:typcase_class	typeref:typename:void	signature:(ostream & s)
typcase_class::copy_Expression	cool-tree.cc	/^Expression typcase_class::copy_Expression()$/;"	f	class:typcase_class	typeref:typename:Expression	signature:()
typcase_class::copy_Expression	cool-tree.h	/^   Expression copy_Expression();$/;"	p	class:typcase_class	typeref:typename:Expression	access:public	signature:()
typcase_class::dump	cool-tree.cc	/^void typcase_class::dump(ostream& stream, int n)$/;"	f	class:typcase_class	typeref:typename:void	signature:(ostream & stream,int n)
typcase_class::dump	cool-tree.h	/^   void dump(ostream& stream, int n);$/;"	p	class:typcase_class	typeref:typename:void	access:public	signature:(ostream & stream,int n)
typcase_class::dump_with_types	dumptype.cc	/^void typcase_class::dump_with_types(ostream& stream, int n)$/;"	f	class:typcase_class	typeref:typename:void	signature:(ostream & stream,int n)
typcase_class::expr	cool-tree.h	/^   Expression expr;$/;"	m	class:typcase_class	typeref:typename:Expression	access:protected
typcase_class::typcase_class	cool-tree.h	/^   typcase_class(Expression a1, Cases a2) {$/;"	f	class:typcase_class	access:public	signature:(Expression a1,Cases a2)
type_decl	cool-tree.h	/^   Symbol type_decl;$/;"	m	class:attr_class	typeref:typename:Symbol	access:protected
type_decl	cool-tree.h	/^   Symbol type_decl;$/;"	m	class:branch_class	typeref:typename:Symbol	access:protected
type_decl	cool-tree.h	/^   Symbol type_decl;$/;"	m	class:formal_class	typeref:typename:Symbol	access:protected
type_decl	cool-tree.h	/^   Symbol type_decl;$/;"	m	class:let_class	typeref:typename:Symbol	access:protected
type_name	cgen.cc	/^	type_name,$/;"	v	typeref:typename:Symbol
type_name	cool-tree.h	/^   Symbol type_name;$/;"	m	class:new__class	typeref:typename:Symbol	access:protected
type_name	cool-tree.h	/^   Symbol type_name;$/;"	m	class:static_dispatch_class	typeref:typename:Symbol	access:protected
unput	ast-lex.cc	/^#define unput(/;"	d	file:	signature:(c)
used_temp	cgen.cc	/^int temp_size, used_temp = 0;$/;"	v	typeref:typename:int
val	cgen.cc	/^	val;$/;"	v	typeref:typename:Symbol
val	cgen.h	/^		int val;$/;"	m	class:BoolConst	typeref:typename:int	access:private
val	cool-tree.h	/^   Boolean val;$/;"	m	class:bool_const_class	typeref:typename:Boolean	access:protected
var_exit	cgen.h	/^		void var_exit() { var_index.exitscope(); }$/;"	f	class:Environment	typeref:typename:void	access:public	signature:()
var_index	cgen.h	/^		SymbolTable<Symbol, int> var_index;$/;"	m	class:Environment	typeref:typename:SymbolTable<Symbol,int>	access:public
var_scopes	cgen.h	/^		int args_size = 0, var_scopes = 0;$/;"	m	class:Environment	typeref:typename:int	access:public
vars_dump	cgen.h	/^		void vars_dump() {$/;"	f	class:Environment	typeref:typename:void	access:public	signature:()
vars_enter	cgen.h	/^		void vars_enter() {$/;"	f	class:Environment	typeref:typename:void	access:public	signature:()
xcons	tree.h	/^template <class Elem> append_node<Elem> *xcons(list_node<Elem> *l, Elem x)$/;"	f	typeref:typename:append_node<Elem> *	signature:(list_node<Elem> * l,Elem x)
xcons	tree.h	/^template <class Elem> append_node<Elem> *xcons(list_node<Elem> *l, Elem x);$/;"	p	typeref:typename:append_node<Elem> *	signature:(list_node<Elem> * l,Elem x)
yy_accept	ast-lex.cc	/^static yyconst flex_int16_t yy_accept[163] =$/;"	v	typeref:typename:yyconst flex_int16_t[163]	file:
yy_at_bol	ast-lex.cc	/^	int yy_at_bol;$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_base	ast-lex.cc	/^static yyconst flex_int16_t yy_base[166] =$/;"	v	typeref:typename:yyconst flex_int16_t[166]	file:
yy_bs_column	ast-lex.cc	/^    int yy_bs_column; \/**< The column count. *\/$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_bs_lineno	ast-lex.cc	/^    int yy_bs_lineno; \/**< The line count. *\/$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_buf_pos	ast-lex.cc	/^	char *yy_buf_pos;		\/* current position in input buffer *\/$/;"	m	struct:yy_buffer_state	typeref:typename:char *	file:	access:public
yy_buf_size	ast-lex.cc	/^	yy_size_t yy_buf_size;$/;"	m	struct:yy_buffer_state	typeref:typename:yy_size_t	file:	access:public
yy_buffer_stack	ast-lex.cc	/^static YY_BUFFER_STATE * yy_buffer_stack = 0; \/**< Stack as an array. *\/$/;"	v	typeref:typename:YY_BUFFER_STATE *	file:
yy_buffer_stack_max	ast-lex.cc	/^static size_t yy_buffer_stack_max = 0; \/**< capacity of stack. *\/$/;"	v	typeref:typename:size_t	file:
yy_buffer_stack_top	ast-lex.cc	/^static size_t yy_buffer_stack_top = 0; \/**< index of top of stack. *\/$/;"	v	typeref:typename:size_t	file:
yy_buffer_state	ast-lex.cc	/^struct yy_buffer_state$/;"	s	file:
yy_buffer_state::yy_at_bol	ast-lex.cc	/^	int yy_at_bol;$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_buffer_state::yy_bs_column	ast-lex.cc	/^    int yy_bs_column; \/**< The column count. *\/$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_buffer_state::yy_bs_lineno	ast-lex.cc	/^    int yy_bs_lineno; \/**< The line count. *\/$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_buffer_state::yy_buf_pos	ast-lex.cc	/^	char *yy_buf_pos;		\/* current position in input buffer *\/$/;"	m	struct:yy_buffer_state	typeref:typename:char *	file:	access:public
yy_buffer_state::yy_buf_size	ast-lex.cc	/^	yy_size_t yy_buf_size;$/;"	m	struct:yy_buffer_state	typeref:typename:yy_size_t	file:	access:public
yy_buffer_state::yy_buffer_status	ast-lex.cc	/^	int yy_buffer_status;$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_buffer_state::yy_ch_buf	ast-lex.cc	/^	char *yy_ch_buf;		\/* input buffer *\/$/;"	m	struct:yy_buffer_state	typeref:typename:char *	file:	access:public
yy_buffer_state::yy_fill_buffer	ast-lex.cc	/^	int yy_fill_buffer;$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_buffer_state::yy_input_file	ast-lex.cc	/^	FILE *yy_input_file;$/;"	m	struct:yy_buffer_state	typeref:typename:FILE *	file:	access:public
yy_buffer_state::yy_is_interactive	ast-lex.cc	/^	int yy_is_interactive;$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_buffer_state::yy_is_our_buffer	ast-lex.cc	/^	int yy_is_our_buffer;$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_buffer_state::yy_n_chars	ast-lex.cc	/^	int yy_n_chars;$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_buffer_status	ast-lex.cc	/^	int yy_buffer_status;$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_c_buf_p	ast-lex.cc	/^static char *yy_c_buf_p = (char *) 0;$/;"	v	typeref:typename:char *	file:
yy_c_buf_p_offset	ast-lex.cc	/^			int yy_c_buf_p_offset =$/;"	v	typeref:typename:int
yy_ch_buf	ast-lex.cc	/^	char *yy_ch_buf;		\/* input buffer *\/$/;"	m	struct:yy_buffer_state	typeref:typename:char *	file:	access:public
yy_chk	ast-lex.cc	/^static yyconst flex_int16_t yy_chk[217] =$/;"	v	typeref:typename:yyconst flex_int16_t[217]	file:
yy_create_buffer	ast-lex.cc	/^    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )$/;"	f	typeref:typename:YY_BUFFER_STATE	signature:(FILE * file,int size)
yy_create_buffer	ast-lex.cc	/^YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );$/;"	p	typeref:typename:YY_BUFFER_STATE	file:	signature:(FILE * file,int size)
yy_def	ast-lex.cc	/^static yyconst flex_int16_t yy_def[166] =$/;"	v	typeref:typename:yyconst flex_int16_t[166]	file:
yy_delete_buffer	ast-lex.cc	/^    void yy_delete_buffer (YY_BUFFER_STATE  b )$/;"	f	typeref:typename:void	signature:(YY_BUFFER_STATE b)
yy_delete_buffer	ast-lex.cc	/^void yy_delete_buffer (YY_BUFFER_STATE b  );$/;"	p	typeref:typename:void	file:	signature:(YY_BUFFER_STATE b)
yy_did_buffer_switch_on_eof	ast-lex.cc	/^static int yy_did_buffer_switch_on_eof;$/;"	v	typeref:typename:int	file:
yy_ec	ast-lex.cc	/^static yyconst flex_int32_t yy_ec[256] =$/;"	v	typeref:typename:yyconst flex_int32_t[256]	file:
yy_fatal_error	ast-lex.cc	/^static void yy_fatal_error (yyconst char msg[]  );$/;"	p	typeref:typename:void	file:	signature:(yyconst char msg[])
yy_fatal_error	ast-lex.cc	/^static void yy_fatal_error (yyconst char* msg )$/;"	f	typeref:typename:void	file:	signature:(yyconst char * msg)
yy_fill_buffer	ast-lex.cc	/^	int yy_fill_buffer;$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_flex_debug	ast-lex.cc	/^int yy_flex_debug = 1;$/;"	v	typeref:typename:int
yy_flex_strlen	ast-lex.cc	/^static int yy_flex_strlen (yyconst char * );$/;"	p	typeref:typename:int	file:	signature:(yyconst char *)
yy_flex_strlen	ast-lex.cc	/^static int yy_flex_strlen (yyconst char * s )$/;"	f	typeref:typename:int	file:	signature:(yyconst char * s)
yy_flex_strncpy	ast-lex.cc	/^static void yy_flex_strncpy (char *,yyconst char *,int );$/;"	p	typeref:typename:void	file:	signature:(char *,yyconst char *,int)
yy_flex_strncpy	ast-lex.cc	/^static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )$/;"	f	typeref:typename:void	file:	signature:(char * s1,yyconst char * s2,int n)
yy_flush_buffer	ast-lex.cc	/^    void yy_flush_buffer (YY_BUFFER_STATE  b )$/;"	f	typeref:typename:void	signature:(YY_BUFFER_STATE b)
yy_flush_buffer	ast-lex.cc	/^void yy_flush_buffer (YY_BUFFER_STATE b  );$/;"	p	typeref:typename:void	file:	signature:(YY_BUFFER_STATE b)
yy_fread	ast-lex.cc	/^#define yy_fread /;"	d	file:
yy_get_next_buffer	ast-lex.cc	/^static int yy_get_next_buffer (void );$/;"	p	typeref:typename:int	file:	signature:(void)
yy_get_previous_state	ast-lex.cc	/^    static yy_state_type yy_get_previous_state (void)$/;"	f	typeref:typename:yy_state_type	file:	signature:(void)
yy_get_previous_state	ast-lex.cc	/^static yy_state_type yy_get_previous_state (void );$/;"	p	typeref:typename:yy_state_type	file:	signature:(void)
yy_hold_char	ast-lex.cc	/^static char yy_hold_char;$/;"	v	typeref:typename:char	file:
yy_init	ast-lex.cc	/^static int yy_init = 0;		\/* whether we need to initialize *\/$/;"	v	typeref:typename:int	file:
yy_init_buffer	ast-lex.cc	/^    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )$/;"	f	typeref:typename:void	file:	signature:(YY_BUFFER_STATE b,FILE * file)
yy_init_buffer	ast-lex.cc	/^static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );$/;"	p	typeref:typename:void	file:	signature:(YY_BUFFER_STATE b,FILE * file)
yy_init_globals	ast-lex.cc	/^static int yy_init_globals (void );$/;"	p	typeref:typename:int	file:	signature:(void)
yy_init_globals	ast-lex.cc	/^static int yy_init_globals (void)$/;"	f	typeref:typename:int	file:	signature:(void)
yy_input_file	ast-lex.cc	/^	FILE *yy_input_file;$/;"	m	struct:yy_buffer_state	typeref:typename:FILE *	file:	access:public
yy_is_interactive	ast-lex.cc	/^	int yy_is_interactive;$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_is_our_buffer	ast-lex.cc	/^	int yy_is_our_buffer;$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_last_accepting_cpos	ast-lex.cc	/^static char *yy_last_accepting_cpos;$/;"	v	typeref:typename:char *	file:
yy_last_accepting_state	ast-lex.cc	/^static yy_state_type yy_last_accepting_state;$/;"	v	typeref:typename:yy_state_type	file:
yy_load_buffer_state	ast-lex.cc	/^static void yy_load_buffer_state  (void)$/;"	f	typeref:typename:void	file:	signature:(void)
yy_load_buffer_state	ast-lex.cc	/^static void yy_load_buffer_state (void );$/;"	p	typeref:typename:void	file:	signature:(void)
yy_meta	ast-lex.cc	/^static yyconst flex_int32_t yy_meta[36] =$/;"	v	typeref:typename:yyconst flex_int32_t[36]	file:
yy_n_chars	ast-lex.cc	/^	int yy_n_chars;$/;"	m	struct:yy_buffer_state	typeref:typename:int	file:	access:public
yy_n_chars	ast-lex.cc	/^static int yy_n_chars;		\/* number of characters read into yy_ch_buf *\/$/;"	v	typeref:typename:int	file:
yy_new_buffer	ast-lex.cc	/^#define yy_new_buffer /;"	d	file:
yy_nxt	ast-lex.cc	/^	flex_int32_t yy_nxt;$/;"	m	struct:yy_trans_info	typeref:typename:flex_int32_t	file:	access:public
yy_nxt	ast-lex.cc	/^static yyconst flex_int16_t yy_nxt[217] =$/;"	v	typeref:typename:yyconst flex_int16_t[217]	file:
yy_reduce_print	ast-parse.cc	/^yy_reduce_print (YYSTYPE *yyvsp, int yyrule)$/;"	f	typeref:typename:void	file:	signature:(YYSTYPE * yyvsp,int yyrule)
yy_rule_linenum	ast-lex.cc	/^static yyconst flex_int16_t yy_rule_linenum[47] =$/;"	v	typeref:typename:yyconst flex_int16_t[47]	file:
yy_scan_buffer	ast-lex.cc	/^YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )$/;"	f	typeref:typename:YY_BUFFER_STATE	signature:(char * base,yy_size_t size)
yy_scan_buffer	ast-lex.cc	/^YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );$/;"	p	typeref:typename:YY_BUFFER_STATE	file:	signature:(char * base,yy_size_t size)
yy_scan_bytes	ast-lex.cc	/^YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )$/;"	f	typeref:typename:YY_BUFFER_STATE	signature:(yyconst char * yybytes,int _yybytes_len)
yy_scan_bytes	ast-lex.cc	/^YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );$/;"	p	typeref:typename:YY_BUFFER_STATE	file:	signature:(yyconst char * bytes,int len)
yy_scan_string	ast-lex.cc	/^YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )$/;"	f	typeref:typename:YY_BUFFER_STATE	signature:(yyconst char * yystr)
yy_scan_string	ast-lex.cc	/^YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );$/;"	p	typeref:typename:YY_BUFFER_STATE	file:	signature:(yyconst char * yy_str)
yy_set_bol	ast-lex.cc	/^#define yy_set_bol(/;"	d	file:	signature:(at_bol)
yy_set_interactive	ast-lex.cc	/^#define yy_set_interactive(/;"	d	file:	signature:(is_interactive)
yy_size_t	ast-lex.cc	/^typedef size_t yy_size_t;$/;"	t	typeref:typename:size_t	file:
yy_stack_print	ast-parse.cc	/^yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)$/;"	f	typeref:typename:void	file:	signature:(yytype_int16 * bottom,yytype_int16 * top)
yy_start	ast-lex.cc	/^static int yy_start = 0;	\/* start state number *\/$/;"	v	typeref:typename:int	file:
yy_state_type	ast-lex.cc	/^typedef int yy_state_type;$/;"	t	typeref:typename:int	file:
yy_switch_to_buffer	ast-lex.cc	/^    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )$/;"	f	typeref:typename:void	signature:(YY_BUFFER_STATE new_buffer)
yy_switch_to_buffer	ast-lex.cc	/^void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );$/;"	p	typeref:typename:void	file:	signature:(YY_BUFFER_STATE new_buffer)
yy_symbol_print	ast-parse.cc	/^yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	typeref:typename:void	file:	signature:(FILE * yyoutput,int yytype,YYSTYPE const * const yyvaluep)
yy_symbol_value_print	ast-parse.cc	/^yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	typeref:typename:void	file:	signature:(FILE * yyoutput,int yytype,YYSTYPE const * const yyvaluep)
yy_trans_info	ast-lex.cc	/^struct yy_trans_info$/;"	s	file:
yy_trans_info::yy_nxt	ast-lex.cc	/^	flex_int32_t yy_nxt;$/;"	m	struct:yy_trans_info	typeref:typename:flex_int32_t	file:	access:public
yy_trans_info::yy_verify	ast-lex.cc	/^	flex_int32_t yy_verify;$/;"	m	struct:yy_trans_info	typeref:typename:flex_int32_t	file:	access:public
yy_try_NUL_trans	ast-lex.cc	/^    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )$/;"	f	typeref:typename:yy_state_type	file:	signature:(yy_state_type yy_current_state)
yy_try_NUL_trans	ast-lex.cc	/^static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );$/;"	p	typeref:typename:yy_state_type	file:	signature:(yy_state_type current_state)
yy_verify	ast-lex.cc	/^	flex_int32_t yy_verify;$/;"	m	struct:yy_trans_info	typeref:typename:flex_int32_t	file:	access:public
yyalloc	ast-lex.cc	/^void *yyalloc (yy_size_t  );$/;"	p	typeref:typename:void *	file:	signature:(yy_size_t)
yyalloc	ast-lex.cc	/^void *yyalloc (yy_size_t  size )$/;"	f	typeref:typename:void *	signature:(yy_size_t size)
yyalloc	ast-parse.cc	/^union yyalloc$/;"	u	file:
yyalloc::yyss	ast-parse.cc	/^  yytype_int16 yyss;$/;"	m	union:yyalloc	typeref:typename:yytype_int16	file:	access:public
yyalloc::yyvs	ast-parse.cc	/^  YYSTYPE yyvs;$/;"	m	union:yyalloc	typeref:typename:YYSTYPE	file:	access:public
yychar	ast-parse.cc	/^#define yychar /;"	d	file:
yychar	ast-parse.cc	/^int yychar;$/;"	v	typeref:typename:int
yycheck	ast-parse.cc	/^static const yytype_int8 yycheck[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yyclearin	ast-parse.cc	/^#define yyclearin	/;"	d	file:
yyconst	ast-lex.cc	/^#define yyconst /;"	d	file:
yyconst	ast-lex.cc	/^#define yyconst$/;"	d	file:
yydebug	ast-parse.cc	/^#define yydebug /;"	d	file:
yydebug	ast-parse.cc	/^int yydebug;$/;"	v	typeref:typename:int
yydefact	ast-parse.cc	/^static const yytype_uint8 yydefact[] =$/;"	v	typeref:typename:const yytype_uint8[]	file:
yydefgoto	ast-parse.cc	/^static const yytype_int8 yydefgoto[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yydestruct	ast-parse.cc	/^yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)$/;"	f	typeref:typename:void	file:	signature:(const char * yymsg,int yytype,YYSTYPE * yyvaluep)
yyensure_buffer_stack	ast-lex.cc	/^static void yyensure_buffer_stack (void );$/;"	p	typeref:typename:void	file:	signature:(void)
yyensure_buffer_stack	ast-lex.cc	/^static void yyensure_buffer_stack (void)$/;"	f	typeref:typename:void	file:	signature:(void)
yyerrok	ast-parse.cc	/^#define yyerrok	/;"	d	file:
yyerror	ast-parse.cc	/^#define yyerror /;"	d	file:
yyfree	ast-lex.cc	/^void yyfree (void *  );$/;"	p	typeref:typename:void	file:	signature:(void *)
yyfree	ast-lex.cc	/^void yyfree (void * ptr )$/;"	f	typeref:typename:void	signature:(void * ptr)
yyget_debug	ast-lex.cc	/^int yyget_debug  (void)$/;"	f	typeref:typename:int	signature:(void)
yyget_in	ast-lex.cc	/^FILE *yyget_in  (void)$/;"	f	typeref:typename:FILE *	signature:(void)
yyget_leng	ast-lex.cc	/^int yyget_leng  (void)$/;"	f	typeref:typename:int	signature:(void)
yyget_lineno	ast-lex.cc	/^int yyget_lineno  (void)$/;"	f	typeref:typename:int	signature:(void)
yyget_out	ast-lex.cc	/^FILE *yyget_out  (void)$/;"	f	typeref:typename:FILE *	signature:(void)
yyget_text	ast-lex.cc	/^char *yyget_text  (void)$/;"	f	typeref:typename:char *	signature:(void)
yyin	ast-lex.cc	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v	typeref:typename:FILE *
yyinput	ast-lex.cc	/^    static int yyinput (void)$/;"	f	typeref:typename:int	file:	signature:(void)
yyinput	ast-lex.cc	/^static int yyinput (void );$/;"	p	typeref:typename:int	file:	signature:(void)
yyleng	ast-lex.cc	/^int yyleng;$/;"	v	typeref:typename:int
yyless	ast-lex.cc	/^#define yyless(/;"	d	file:	signature:(n)
yylex	ast-lex.cc	/^#define yylex /;"	d	file:
yylex	ast-lex.cc	/^extern int yylex (void);$/;"	p	typeref:typename:int	file:	signature:(void)
yylex	ast-parse.cc	/^#define yylex /;"	d	file:
yylex	ast-parse.cc	/^extern int yylex();           \/* the entry point to the lexer  *\/$/;"	p	typeref:typename:int	file:	signature:()
yylex_destroy	ast-lex.cc	/^int yylex_destroy  (void)$/;"	f	typeref:typename:int	signature:(void)
yylineno	ast-lex.cc	/^int yylineno = 1;$/;"	v	typeref:typename:int
yylineno	cool-tree.handcode.h	/^#define yylineno /;"	d
yyltype	cool-parse.h	/^# define yyltype /;"	d
yylval	ast-lex.cc	/^#define yylval /;"	d	file:
yylval	ast-parse.cc	/^#define yylval /;"	d	file:
yylval	ast-parse.cc	/^YYSTYPE yylval;$/;"	v	typeref:typename:YYSTYPE
yymore	ast-lex.cc	/^#define yymore(/;"	d	file:	signature:()
yynerrs	ast-parse.cc	/^#define yynerrs /;"	d	file:
yynerrs	ast-parse.cc	/^int yynerrs;$/;"	v	typeref:typename:int
yyout	ast-lex.cc	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v	typeref:typename:FILE *
yypact	ast-parse.cc	/^static const yytype_int8 yypact[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yyparse	ast-parse.cc	/^#define yyparse /;"	d	file:
yyparse	ast-parse.cc	/^int yyparse ();$/;"	p	typeref:typename:int	file:	signature:()
yyparse	ast-parse.cc	/^int yyparse (void *YYPARSE_PARAM);$/;"	p	typeref:typename:int	file:	signature:(void * YYPARSE_PARAM)
yyparse	ast-parse.cc	/^int yyparse (void);$/;"	p	typeref:typename:int	file:	signature:(void)
yyparse	ast-parse.cc	/^yyparse (void *YYPARSE_PARAM)$/;"	f	typeref:typename:int	signature:(void * YYPARSE_PARAM)
yypgoto	ast-parse.cc	/^static const yytype_int8 yypgoto[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yypop_buffer_state	ast-lex.cc	/^void yypop_buffer_state (void );$/;"	p	typeref:typename:void	file:	signature:(void)
yypop_buffer_state	ast-lex.cc	/^void yypop_buffer_state (void)$/;"	f	typeref:typename:void	signature:(void)
yyprhs	ast-parse.cc	/^static const yytype_uint8 yyprhs[] =$/;"	v	typeref:typename:const yytype_uint8[]	file:
yypush_buffer_state	ast-lex.cc	/^void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );$/;"	p	typeref:typename:void	file:	signature:(YY_BUFFER_STATE new_buffer)
yypush_buffer_state	ast-lex.cc	/^void yypush_buffer_state (YY_BUFFER_STATE new_buffer )$/;"	f	typeref:typename:void	signature:(YY_BUFFER_STATE new_buffer)
yyr1	ast-parse.cc	/^static const yytype_uint8 yyr1[] =$/;"	v	typeref:typename:const yytype_uint8[]	file:
yyr2	ast-parse.cc	/^static const yytype_uint8 yyr2[] =$/;"	v	typeref:typename:const yytype_uint8[]	file:
yyrealloc	ast-lex.cc	/^void *yyrealloc  (void * ptr, yy_size_t  size )$/;"	f	typeref:typename:void *	signature:(void * ptr,yy_size_t size)
yyrealloc	ast-lex.cc	/^void *yyrealloc (void *,yy_size_t  );$/;"	p	typeref:typename:void *	file:	signature:(void *,yy_size_t)
yyrestart	ast-lex.cc	/^			yyrestart(yyin  );$/;"	p	file:	signature:(yyin)
yyrestart	ast-lex.cc	/^    void yyrestart  (FILE * input_file )$/;"	f	typeref:typename:void	signature:(FILE * input_file)
yyrestart	ast-lex.cc	/^void yyrestart (FILE *input_file  );$/;"	p	typeref:typename:void	file:	signature:(FILE * input_file)
yyrhs	ast-parse.cc	/^static const yytype_int8 yyrhs[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yyrline	ast-parse.cc	/^static const yytype_uint8 yyrline[] =$/;"	v	typeref:typename:const yytype_uint8[]	file:
yyset_debug	ast-lex.cc	/^void yyset_debug (int  bdebug )$/;"	f	typeref:typename:void	signature:(int bdebug)
yyset_in	ast-lex.cc	/^void yyset_in (FILE *  in_str )$/;"	f	typeref:typename:void	signature:(FILE * in_str)
yyset_lineno	ast-lex.cc	/^void yyset_lineno (int  line_number )$/;"	f	typeref:typename:void	signature:(int line_number)
yyset_out	ast-lex.cc	/^void yyset_out (FILE *  out_str )$/;"	f	typeref:typename:void	signature:(FILE * out_str)
yyss	ast-parse.cc	/^  yytype_int16 yyss;$/;"	m	union:yyalloc	typeref:typename:yytype_int16	file:	access:public
yystos	ast-parse.cc	/^static const yytype_uint8 yystos[] =$/;"	v	typeref:typename:const yytype_uint8[]	file:
yystpcpy	ast-parse.cc	/^#   define yystpcpy /;"	d	file:
yystpcpy	ast-parse.cc	/^yystpcpy (char *yydest, const char *yysrc)$/;"	f	typeref:typename:char *	file:	signature:(char * yydest,const char * yysrc)
yystrlen	ast-parse.cc	/^#   define yystrlen /;"	d	file:
yystrlen	ast-parse.cc	/^yystrlen (const char *yystr)$/;"	f	typeref:typename:YYSIZE_T	file:	signature:(const char * yystr)
yystype	ast-parse.cc	/^# define yystype /;"	d	file:
yystype	ast-parse.h	/^# define yystype /;"	d
yystype	cool-parse.h	/^# define yystype /;"	d
yysyntax_error	ast-parse.cc	/^yysyntax_error (char *yyresult, int yystate, int yychar)$/;"	f	typeref:typename:YYSIZE_T	file:	signature:(char * yyresult,int yystate,int yychar)
yysyntax_error::YYERROR_VERBOSE_ARGS_MAXIMUM	ast-parse.cc	/^      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };$/;"	e	enum:yysyntax_error::__anonb60ba6e90103	file:	access:public
yytable	ast-parse.cc	/^static const yytype_uint8 yytable[] =$/;"	v	typeref:typename:const yytype_uint8[]	file:
yyterminate	ast-lex.cc	/^#define yyterminate(/;"	d	file:	signature:()
yytext	ast-lex.cc	/^char *yytext;$/;"	v	typeref:typename:char *
yytext_ptr	ast-lex.cc	/^#define yytext_ptr /;"	d	file:
yytname	ast-parse.cc	/^static const char *const yytname[] =$/;"	v	typeref:typename:const char * const[]	file:
yytnamerr	ast-parse.cc	/^yytnamerr (char *yyres, const char *yystr)$/;"	f	typeref:typename:YYSIZE_T	file:	signature:(char * yyres,const char * yystr)
yytokentype	ast-parse.cc	/^   enum yytokentype {$/;"	g	file:
yytokentype	ast-parse.h	/^   enum yytokentype {$/;"	g
yytokentype	cool-parse.h	/^   enum yytokentype {$/;"	g
yytoknum	ast-parse.cc	/^static const yytype_uint16 yytoknum[] =$/;"	v	typeref:typename:const yytype_uint16[]	file:
yytranslate	ast-parse.cc	/^static const yytype_uint8 yytranslate[] =$/;"	v	typeref:typename:const yytype_uint8[]	file:
yytype_int16	ast-parse.cc	/^typedef YYTYPE_INT16 yytype_int16;$/;"	t	typeref:typename:YYTYPE_INT16	file:
yytype_int16	ast-parse.cc	/^typedef short int yytype_int16;$/;"	t	typeref:typename:short int	file:
yytype_int8	ast-parse.cc	/^typedef YYTYPE_INT8 yytype_int8;$/;"	t	typeref:typename:YYTYPE_INT8	file:
yytype_int8	ast-parse.cc	/^typedef short int yytype_int8;$/;"	t	typeref:typename:short int	file:
yytype_int8	ast-parse.cc	/^typedef signed char yytype_int8;$/;"	t	typeref:typename:signed char	file:
yytype_uint16	ast-parse.cc	/^typedef YYTYPE_UINT16 yytype_uint16;$/;"	t	typeref:typename:YYTYPE_UINT16	file:
yytype_uint16	ast-parse.cc	/^typedef unsigned short int yytype_uint16;$/;"	t	typeref:typename:unsigned short int	file:
yytype_uint8	ast-parse.cc	/^typedef YYTYPE_UINT8 yytype_uint8;$/;"	t	typeref:typename:YYTYPE_UINT8	file:
yytype_uint8	ast-parse.cc	/^typedef unsigned char yytype_uint8;$/;"	t	typeref:typename:unsigned char	file:
yyunput	ast-lex.cc	/^    static void yyunput (int c, register char * yy_bp )$/;"	f	typeref:typename:void	file:	signature:(int c,register char * yy_bp)
yyunput	ast-lex.cc	/^    static void yyunput (int c,char *buf_ptr  );$/;"	p	typeref:typename:void	file:	signature:(int c,char * buf_ptr)
yyvs	ast-parse.cc	/^  YYSTYPE yyvs;$/;"	m	union:yyalloc	typeref:typename:YYSTYPE	file:	access:public
yywrap	ast-lex.cc	/^#define yywrap(/;"	d	file:	signature:()
~list_node	tree.h	/^    virtual ~list_node() { }$/;"	f	class:list_node	access:public	signature:()
~tree_node	tree.h	/^    virtual ~tree_node() { }$/;"	f	class:tree_node	access:public	signature:()
